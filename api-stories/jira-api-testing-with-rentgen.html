<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>What a Real Jira API Request Reveals Under Rentgen Testing</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description"
    content="Rentgen is a secure, local-only API testing tool. No accounts, no tracking, no logging – just deep backend tests that stay on your machine." />
  <link rel="canonical" href="https://rentgen.io/api-stories/jira-api-testing-with-rentgen.html" />

  <!-- Favicon -->
  <link rel="icon" type="image/x-icon" href="../assets/favicon.ico" />
  <link rel="icon" type="image/png" href="../assets/rentgen-logo.png" />
  <link rel="apple-touch-icon" href="../assets/rentgen-logo.png" />

  <!-- Open Graph / Social -->
  <meta property="og:title" content="Rentgen – Secure Local API Testing Tool" />
  <meta property="og:description" content="No cloud. No tracking. No logs. Just brutal API testing on your machine." />
  <meta property="og:image" content="https://rentgen.io/assets/og-image.png" />
  <meta property="og:url" content="https://rentgen.io/" />
  <meta property="og:type" content="website" />

  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="Rentgen – Secure Local API Testing Tool" />
  <meta name="twitter:description" content="No cloud. No tracking. No logs. Just brutal API testing on your machine." />
  <meta name="twitter:image" content="https://rentgen.io/assets/og-image.png" />

  <link rel="stylesheet" href="../styles.css" />
</head>

<body>
  <header class="site-header">
    <div class="container header-inner">
      <a href="https://rentgen.io/#top" class="brand">
        <img src="../assets/rentgen-logo.png" class="brand-logo" />
        <span class="brand-name">Rentgen</span>
      </a>
      <button class="nav-toggle" aria-label="Toggle navigation">
        <span></span><span></span>
      </button>
      <nav class="site-nav">
        <a href="https://rentgen.io/#features">Features</a>
        <a href="https://rentgen.io/#security">Security</a>
        <a href="https://rentgen.io/#downloads">Downloads</a>
        <a href="https://rentgen.io/#cases">Case studies</a>
        <a href="https://rentgen.io/#github">GitHub</a>
        <a href="https://rentgen.io/api-stories/">API Stories</a>
      </nav>
    </div>
  </header>

  <main class="section">

<article class="container article">
  <header class="article-header">
    <h1>What a Real Jira API Request Reveals Under Rentgen Testing</h1>
    <p class="article-meta">
      Tested with Rentgen · December 2025
    </p>
  </header>

  <div class="article-content">
    <p>
      Atlassian has been around since the mid-2000s. Jira is one of those tools that almost every developer has used
      at least once — and many still use daily.
    </p>

    <p>
      No matter how many companies you change, Jira somehow always shows up again. And honestly — for good reasons.
      It’s a solid product.
    </p>

    <p>
      An old developer once told me: “Jira is like heroin. Everyone hates it — but once you’ve used it, you can’t live without it.”
      That joke stuck with me because it’s painfully accurate.
    </p>

    <p>
      So when you build an API testing tool, you don’t skip Jira.
    </p>

    <h2>What was tested</h2>
    <p>
      I tested a real Jira API request — creating an issue. No mocks. No guessing. No “example payloads”.
      I took a real cURL request, imported it into Rentgen, and ran the tests.
    </p>

    <p>
      Import cURL → Send → Generate &amp; Run Tests. Then I went to make coffee. When I came back, I had results.
    </p>

    <p><strong>Endpoint:</strong></p>
    <pre><code>POST https://rentgen.atlassian.net/rest/api/3/issue?updateHistory=true&amp;applyDefaultValues=false&amp;skipAutoWatch=true</code></pre>

    <h2>First impression: the basics are solid</h2>
      <figure>
        <img width=100%  src="../assets/api-stories/rentgen-Atlassian-security-test-results.jpg" alt="Jira API request used as input for Rentgen" />
        <figcaption>Rentgen Security Tests</figcaption>
    </figure>
    <p>
      Most recommended security headers are there. That’s good. That’s expected from Atlassian.
    </p>

    <h3>Clickjacking protection — missing</h3>
    <p>
      <code>X-Frame-Options</code> or <code>frame-ancestors</code> is missing.
    </p>

    <p>
      Is this critical? No. Is this catastrophic? Also no. But if you ask an 8-year-old:
      this header tells browsers not to allow your site to be embedded inside someone else’s page and trick users.
    </p>

    <p>
      Low severity. Easy fix. Still worth pointing out.
    </p>

    <h2>Where things start getting ugly</h2>

    <h3>Unsupported HTTP method handling</h3>
    <p>
      When you send an unsupported HTTP method, the API responds with <strong>403 Forbidden</strong>.
    </p>

    <p>
      This is bad — because 403 means “you don’t have permission”. So what happens in real life?
      You check permissions, tokens, scopes, and debug auth for hours — until you finally realize:
      you just used the wrong HTTP method.
    </p>

    <p>
      This should be <strong>405 Method Not Allowed</strong> (or <strong>501 Not Implemented</strong>).
      Returning 403 here is misleading and wastes time.
    </p>

    <h3>404 Not Found test — fails</h3>
    <p>
      Rentgen replaces the last path segment with a non-existent one and expects <strong>404 Not Found</strong>.
      Instead, Jira returns <strong>405 Method Not Allowed</strong>.
    </p>

    <p>
      405 says “the resource exists, but the method is wrong”. 404 says “this resource does not exist”.
      These are very different situations — and mixing them breaks client logic, retries, and error handling.
    </p>

    <h3>Large payload test — the worst one</h3>
    <p>
      Expected: <strong>413 Payload Too Large</strong>. Actual: <strong>400 Bad Request</strong>.
    </p>

    <p>
      Yes, 400 technically says “the request is bad”. But the problem is how the system gets there.
      The API accepts the full 10 MB payload, processes it, validates it — and only then rejects it.
      You can feel it in response time.
    </p>

    <p>
      A proper implementation should reject immediately, drop the payload early, and return 413 without processing.
      This is a performance and resilience issue, not just semantics.
    </p>

    <h2>Performance</h2>
    <figure>
        <img width=100%  src="../assets/api-stories/attlasian-performance-rentgen-test.jpg" alt="Jira API request used as input for Rentgen" />
        <figcaption>Rentgen Performance Insights</figcaption>
    </figure>
    <p>
      Median response time is ~370 ms — perfectly fine. But with just 10 concurrent users, p50 jumps to 1331 ms
      and p90/p95 climb even higher. That doesn’t mean Jira is “slow”, but it does mean something interesting is
      happening under concurrency — and it’s worth digging deeper.
    </p>

    <h2>Data-driven tests: where Rentgen shines</h2>
    <p>
      This is always the most interesting part.
    </p>

    <h3>Automatic trimming test</h3>
    <p>
      Rentgen automatically checks whether input values are trimmed:
      if trimming works — the test passes; if trimming fails — it fails; if the value doesn’t come back in the response —
      Rentgen flags it as manual verification needed.
    </p>
    <figure>
        <img width=100%  src="../assets/api-stories/rentgen-data-driven-trimming-tests.jpg" alt="Jira API request used as input for Rentgen" />
        <figcaption>Rentgen Trimm Test</figcaption>
    </figure>

    <p>
      In this case:
    </p>

    <pre><code>body.fields.summary = " rentgen test 123 "</code></pre>

    <p>
      Result: informational. So I checked the UI. And yes — the value is not trimmed.
    </p>
     <figure>
        <img width=100%  src="../assets/api-stories/attlasian-not-trimmed-value.jpg" alt="Jira API request used as input for Rentgen" />
        <figcaption>Rentgen Trimm Test</figcaption>
    </figure>

    <p>
      Why is this a bug? Because invisible spaces break integrations, exports, comparisons, and create “ghost” issues
      nobody understands. Users don’t see spaces. Systems do.
    </p>



    <h3>Weak field validation examples</h3>
    <p>
      Some examples that stood out:
    </p>

    <ul>
      <li>
        <code>body.fields.priority.iconUrl</code> accepts any string, even though it’s clearly meant to be a URL.
        Other developers will trust it and break UI later.
      </li>
      <li>
        <code>body.fields.duedate</code>: “5555-01-02” is accepted. Semantically invalid. UI can’t realistically handle this.
      </li>
      <li>
        <code>query.applyDefaultValues</code> is a boolean field. It rejects “true” as string and rejects null,
        but accepts 0 and converts it to false. Not critical. Not pretty. If a field is boolean — treat it like one.
      </li>
    </ul>

    <h2>Final thoughts</h2>
    <p>
      In about two minutes, without writing a single script, I got real protocol issues, real semantics problems,
      real performance signals, and real data validation gaps.
    </p>

    <p>
      This is not “testing is finished”. This is where testing starts.
    </p>

    <p>
      Rentgen doesn’t replace Jira testing. It forces you to see things you normally miss — before your users do.
    </p>

    <p>
      Coffee well spent.
    </p>
  </div>
</article>


  </main>

  <footer class="site-footer">
    <div class="container footer-inner">
      <span>© <span id="year"></span> Rentgen</span>
      <span class="footer-note">Built for testers, by a tester.</span>
    </div>
  </footer>

  <script src="../script.js"></script>
</body>
</html>
