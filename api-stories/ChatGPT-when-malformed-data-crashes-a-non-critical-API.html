<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>API Story: Cache-Control for Private API — preventing “ghost data” in caches</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description"
    content="Rentgen is a secure, local-only API testing tool. No accounts, no tracking, no logging – just deep backend tests that stay on your machine." />
  <link rel="canonical" href="https://rentgen.io/api-stories/404-not-found-handling.html" />

  <!-- Favicon -->
  <link rel="icon" type="image/x-icon" href="../assets/favicon.ico" />
  <link rel="icon" type="image/png" href="../assets/rentgen-logo.png" />
  <link rel="apple-touch-icon" href="../assets/rentgen-logo.png" />

  <!-- Open Graph / Social -->
  <meta property="og:title" content="Rentgen – Secure Local API Testing Tool" />
  <meta property="og:description" content="No cloud. No tracking. No logs. Just brutal API testing on your machine." />
  <meta property="og:image" content="https://rentgen.io/assets/og-image.png" />
  <meta property="og:url" content="https://rentgen.io/" />
  <meta property="og:type" content="website" />

  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="Rentgen – Secure Local API Testing Tool" />
  <meta name="twitter:description" content="No cloud. No tracking. No logs. Just brutal API testing on your machine." />
  <meta name="twitter:image" content="https://rentgen.io/assets/og-image.png" />

  <link rel="stylesheet" href="../styles.css" />
</head>

<body>
  <header class="site-header">
    <div class="container header-inner">
      <a href="https://rentgen.io/#top" class="brand">
        <img src="../assets/rentgen-logo.png" class="brand-logo" />
        <span class="brand-name">Rentgen</span>
      </a>
      <button class="nav-toggle" aria-label="Toggle navigation">
        <span></span><span></span>
      </button>
      <nav class="site-nav">
        <a href="https://rentgen.io/#features">Features</a>
        <a href="https://rentgen.io/#security">Security</a>
        <a href="https://rentgen.io/#downloads">Downloads</a>
        <a href="https://rentgen.io/#cases">Case studies</a>
        <a href="https://rentgen.io/#github">GitHub</a>
        <a href="https://rentgen.io/api-stories/">API Stories</a>
      </nav>
    </div>
  </header>

  <main class="section">

    <article class="container article">
      <header class="article-header">
        <h1>ChatGPT — when malformed data crashes a “non-critical” API</h1>
        <p class="article-meta">
          Rentgen API Stories · January 2026
        </p>
      </header>

      <div class="article-content">
        <p>
          Telemetry endpoints are not business APIs. They don’t process money, don’t return user data, and don’t decide outcomes.
          That’s exactly why they are dangerous when implemented carelessly.
        </p>

        <p>
          This story documents a case where malformed input causes a <strong>500 Internal Server Error</strong> in a telemetry endpoint used by ChatGPT —
          something that should not happen in a production-grade system, regardless of the endpoint’s “importance”.
        </p>

        <h2>What this check is — and what it is not</h2>
        <p>
          This is not fuzzing. It’s not brute force. It’s not “security research”.
          It is the simplest possible workflow: replaying a real request and changing one field.
        </p>

        <p>
          The goal is to validate a basic API contract rule: malformed client input must fail with a 4xx response, not crash the server.
          Telemetry is not exempt from that rule.
        </p>

        <h2>What was tested</h2>
        <p>
          When a user interacts with a ChatGPT response (for example, pressing the <strong>Copy</strong> button),
          the frontend sends a telemetry request to an internal endpoint:
        </p>

        <p>
          <code>POST https://chatgpt.com/backend-api/conversation/implicit_message_feedback</code>
        </p>

        <p>
          The payload includes metadata about the interaction, including a <code>message_id</code>.
          The expected format of <code>message_id</code> is clearly a UUID, for example:
        </p>

        <pre>
          <code>
            "message_id": "74fe5c77-4444-4455-85f7-cf58f679b2d0"
          </code>
        </pre>

        <p>
          (The value above is randomized.)
        </p>

        <figure>
          <img width="100%" src="../assets/api-stories/chatGpt-rentgen-test-flow.gif" alt="Copy cURL from browser DevTools, paste into Rentgen, run tests" />
          <figcaption>Copy the real cURL from DevTools → paste into Rentgen → run. No guessing, no setup.</figcaption>
        </figure>

        <h2>How it was tested</h2>
        <p>
          The workflow was intentionally minimal:
          open DevTools, copy the exact cURL generated by ChatGPT, paste into Rentgen, run the request,
          then replace <code>message_id</code> with invalid values and observe the responses.
        </p>

        <p>
          Rentgen did not need any special configuration here. This was a single captured request, replayed as-is.
        </p>

        <h2>What Rentgen found</h2>
        <p>
          When <code>message_id</code> was replaced with arbitrary <strong>non-ASCII strings</strong>, the endpoint consistently returned:
          <strong>500 Internal Server Error</strong>.
        </p>

        <p>
          Examples that triggered a 500:
        </p>

        <figure>
          <img width="100%" src="../assets/api-stories/chatGPT-500-system-error.png" alt="500 System Error" />
          <figcaption>500 System Error</figcaption>
        </figure>

        <pre>
          <code>
            "Tên Việt Nam Họ",
            "Lithuanian ąčęėįšųūž", 
            Danish ÆØÅëáçóáéíâ"
          </code>
        </pre>

        <p>
          All of these are valid JSON strings. The failure is not “bad JSON”. The failure is server-side handling.
        </p>

        <p>
          Interestingly, when <code>message_id</code> was replaced with numbers or booleans, the endpoint returned:
          <strong>422 Unprocessable Entity</strong>.
          That suggests validation exists — but only at the <em>type</em> level, not at the <em>format</em> level.
        </p>

        <h2>Why this is not OK</h2>
        <p>
          A <strong>500 error is never an acceptable response to malformed client input</strong>.
          If a client sends a random string where a UUID is expected, correct responses are 4xx:
          <code>400 Bad Request</code> or <code>422 Unprocessable Entity</code>.
        </p>

        <p>
          OpenAI already returns <code>422</code> in other cases, which is perfectly reasonable and consistent with strict validation.
          A <code>500</code> response means something else happened: the server accepted the input, attempted to process it, and crashed at runtime.
          That is an input validation bug, not a telemetry quirk.
        </p>

        <h2>“It’s just telemetry” is a bad excuse</h2>
        <p>
          Telemetry endpoints are often called automatically, frequently, and by uncontrolled clients (browsers, extensions, proxies, bots).
          If an endpoint can be crashed cheaply by malformed input and is not isolated or aggressively rate-limited,
          it becomes a stability and abuse risk.
        </p>

        <p>
          At best, it generates log noise and alert fatigue. At worst, it becomes a denial-of-service vector.
          Telemetry should fail quietly. It should not crash loudly.
        </p>

        <h2>What a robust implementation should do</h2>
        <p>
          The expected flow is boring and correct: validate schema and UUID format first, fail fast with a 4xx response on invalid input,
          then parse and process only validated data. If telemetry processing fails internally, it should be handled gracefully without returning 500s.
        </p>

        <h2>Rentgen certificate result</h2>
        <p>
          When evaluated against Rentgen’s certificate criteria, this endpoint scores <strong>15 / 100</strong> and does not qualify for a certificate badge.
          The score reflects unsafe assumptions about input format and a runtime crash pattern that production systems should not exhibit.
        </p>

        <h2>Final thoughts</h2>
        <p>
          This kind of bug is easy to introduce, cheap to fix, and expensive to discover during an incident.
          The surprising part is not that it exists — it’s how quickly it was found: one copied cURL, pasted into Rentgen, and reproduced in minutes.
          That is the entire point of <strong>Automation Before Automation</strong>.
        </p>
      </div>
    </article>

  </main>


  <footer class="site-footer">
    <div class="container footer-inner">
      <span>© <span id="year"></span> Rentgen</span>
      <span class="footer-note">Built for testers, by a tester.</span>
    </div>
  </footer>

  <script src="../script.js"></script>
</body>
</html>
