<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>API Story: Cache-Control for Private API ‚Äî preventing ‚Äúghost data‚Äù in caches</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description"
    content="Rentgen is a secure, local-only API testing tool. No accounts, no tracking, no logging ‚Äì just deep backend tests that stay on your machine." />
  <link rel="canonical" href="https://rentgen.io/api-stories/cache-control-for-private-api.html" />

  <!-- Favicon -->
  <link rel="icon" type="image/x-icon" href="../assets/favicon.ico" />
  <link rel="icon" type="image/png" href="../assets/rentgen-logo.png" />
  <link rel="apple-touch-icon" href="../assets/rentgen-logo.png" />

  <!-- Open Graph / Social -->
  <meta property="og:title" content="Rentgen ‚Äì Secure Local API Testing Tool" />
  <meta property="og:description" content="No cloud. No tracking. No logs. Just brutal API testing on your machine." />
  <meta property="og:image" content="https://rentgen.io/assets/og-image.png" />
  <meta property="og:url" content="https://rentgen.io/" />
  <meta property="og:type" content="website" />

  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="Rentgen ‚Äì Secure Local API Testing Tool" />
  <meta name="twitter:description" content="No cloud. No tracking. No logs. Just brutal API testing on your machine." />
  <meta name="twitter:image" content="https://rentgen.io/assets/og-image.png" />

  <link rel="stylesheet" href="../styles.css" />
</head>

<body>
  <header class="site-header">
    <div class="container header-inner">
      <a href="https://rentgen.io/#top" class="brand">
        <img src="../assets/rentgen-logo.png" class="brand-logo" />
        <span class="brand-name">Rentgen</span>
      </a>
      <button class="nav-toggle" aria-label="Toggle navigation">
        <span></span><span></span>
      </button>
      <nav class="site-nav">
        <a href="https://rentgen.io/#features">Features</a>
        <a href="https://rentgen.io/#security">Security</a>
        <a href="https://rentgen.io/#downloads">Downloads</a>
        <a href="https://rentgen.io/#cases">Case studies</a>
        <a href="https://rentgen.io/#github">GitHub</a>
        <a href="https://rentgen.io/api-stories/">API Stories</a>
      </nav>
    </div>
  </header>

  <main class="section">

    <article class="container article">
      <header class="article-header">
        <h1>404 Not Found Handling ‚Äî when your API pretends missing endpoints exist</h1>
        <p class="article-meta">
          Rentgen API Stories ¬∑ January 2026
        </p>
      </header>

      <div class="article-content">
        <p>
          <code>404 Not Found</code> is one of the most basic signals an API can send.
          It says: <em>‚Äúthis endpoint does not exist‚Äù</em>.
          When that signal is wrong, everything built on top of the API becomes harder to reason about.
        </p>

        <p>
          This test looks trivial.
          In practice, it is broken far more often than teams expect ‚Äî
          including in mature, production systems.
        </p>

        <h2>What was tested</h2>
        <p>
          Rentgen takes a known, valid API request and deliberately corrupts the URL path
          by appending random segments that should not exist.
          The request is otherwise unchanged.
        </p>

        <p>
          The expectation is simple and unambiguous:
        </p>
        <ul>
          <li>If the endpoint does not exist, the API must return <code>404 Not Found</code></li>
        </ul>

        <figure>
          <img width="100%" src="../assets/api-stories/404-not-found-handling.png" alt="404 Not Found handling test showing incorrect 200 OK response" />
          <figcaption>Rentgen appends a non-existent path and expects a clear 404 response</figcaption>
        </figure>

        <h2>What Rentgen found</h2>
        <ul>
          <li><strong>TEST:</strong> 404 Not Found Handling</li>
          <li><strong>Expected:</strong> <code>404 Not Found</code></li>
          <li><strong>Actual:</strong> <code>200 OK</code></li>
          <li><strong>Status:</strong> <strong>üî¥ Fail</strong></li>
        </ul>

        <h2>Why this is a failure (not an edge case)</h2>
        <p>
          Returning <code>200 OK</code> for a non-existent endpoint is not harmless.
          It tells the client:
          <em>‚ÄúThis request was valid and processed correctly.‚Äù</em>
        </p>

        <p>
          That message is false.
          And false signals are far more damaging than explicit errors.
        </p>

        <h2>The debugging trap</h2>
        <p>
          Imagine a small typo in the URL:
        </p>
        <ul>
          <li>a missing slash</li>
          <li>a wrong version segment</li>
          <li>a copied link with an extra character</li>
        </ul>

        <p>
          Instead of a clean <code>404</code>, the client receives <code>200 OK</code>.
          What happens next is predictable:
        </p>
        <ul>
          <li>developers inspect request headers</li>
          <li>they validate payloads</li>
          <li>they check authentication and permissions</li>
          <li>they re-run requests again and again</li>
        </ul>

        <p>
          The real problem ‚Äî the endpoint does not exist ‚Äî
          is the one thing nobody questions.
        </p>

        <h2>The operational cost nobody notices</h2>
        <p>
          Now imagine this at scale.
        </p>

        <p>
          Clients are calling non-existent URLs.
          Integrations are misconfigured.
          Old mobile versions are still in the wild.
        </p>

        <p>
          But your API responds with <code>200 OK</code>.
        </p>

        <p>
          In monitoring systems and dashboards:
        </p>
        <ul>
          <li>everything looks healthy</li>
          <li>no error spikes</li>
          <li>no alerts</li>
        </ul>

        <p>
          Meanwhile:
          users complain,
          partners get frustrated,
          and engineers get blamed ‚Äî
          because logs and metrics insist everything is fine.
        </p>

        <h2>Why this happens in real systems</h2>
        <p>
          Most of the time, this behavior is accidental.
        </p>

        <p>
          Common causes include:
        </p>
        <ul>
          <li>catch-all routes that return default responses</li>
          <li>frameworks configured to fall back to a generic handler</li>
          <li>reverse proxies or gateways rewriting paths</li>
          <li>‚Äútemporary‚Äù logic added to keep clients from breaking</li>
        </ul>

        <p>
          Over time, the API stops enforcing its own boundaries.
        </p>

        <h2>Why this is a real bug</h2>
        <p>
          APIs are contracts.
          A correct contract must clearly separate:
        </p>
        <ul>
          <li>existing resources</li>
          <li>invalid requests</li>
          <li>non-existent endpoints</li>
        </ul>

        <p>
          When non-existent endpoints return <code>200 OK</code>,
          the API loses the ability to say ‚Äúno‚Äù.
          And without that, clients cannot reliably detect mistakes.
        </p>

        <h2>How other teams usually discover this</h2>
        <p>
          Rarely through tests.
        </p>

        <p>
          Much more often through:
        </p>
        <ul>
          <li>customer complaints</li>
          <li>support tickets</li>
          <li>confusing Grafana dashboards</li>
          <li>long debugging sessions with no clear root cause</li>
        </ul>

        <p>
          By the time someone notices, the behavior is already depended on by clients ‚Äî
          making it painful to fix.
        </p>

        <h2>How to fix it</h2>
        <p>
          The rule is simple:
        </p>
        <ul>
          <li>If the endpoint does not exist, return <code>404 Not Found</code></li>
          <li>Do not reuse success responses for unknown routes</li>
          <li>Ensure gateways and proxies do not mask missing paths</li>
        </ul>

        <p>
          If your framework supports automatic 404 handling,
          make sure it is not overridden by custom routing logic.
        </p>

        <h2>Why Rentgen checks this</h2>
        <p>
          Because this bug hides in plain sight.
        </p>

        <p>
          It doesn‚Äôt crash systems.
          It doesn‚Äôt trigger alerts.
          It quietly drains engineering time and erodes trust in monitoring.
        </p>

        <p>
          Rentgen deliberately generates invalid URLs
          to verify that the API still tells the truth
          when something does not exist.
        </p>

        <h2>Final thoughts</h2>
        <p>
          A correct <code>404</code> is not about being strict.
          It‚Äôs about being honest.
        </p>

        <p>
          When an API can clearly say ‚Äúthis endpoint does not exist‚Äù,
          every other response becomes easier to trust.
          And trust, in production systems, is worth far more
          than pretending everything is OK.
        </p>
      </div>
    </article>


  </main>

  <footer class="site-footer">
    <div class="container footer-inner">
      <span>¬© <span id="year"></span> Rentgen</span>
      <span class="footer-note">Built for testers, by a tester.</span>
    </div>
  </footer>

  <script src="../script.js"></script>
</body>
</html>
