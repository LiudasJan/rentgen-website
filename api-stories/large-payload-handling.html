<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>API Story: Cache-Control for Private API — preventing “ghost data” in caches</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description"
    content="Rentgen is a secure, local-only API testing tool. No accounts, no tracking, no logging – just deep backend tests that stay on your machine." />
  <link rel="canonical" href="https://rentgen.io/api-stories/large-payload-handling.html" />

  <!-- Favicon -->
  <link rel="icon" type="image/x-icon" href="../assets/favicon.ico" />
  <link rel="icon" type="image/png" href="../assets/rentgen-logo.png" />
  <link rel="apple-touch-icon" href="../assets/rentgen-logo.png" />

  <!-- Open Graph / Social -->
  <meta property="og:title" content="Rentgen – Secure Local API Testing Tool" />
  <meta property="og:description" content="No cloud. No tracking. No logs. Just brutal API testing on your machine." />
  <meta property="og:image" content="https://rentgen.io/assets/og-image.png" />
  <meta property="og:url" content="https://rentgen.io/" />
  <meta property="og:type" content="website" />

  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="Rentgen – Secure Local API Testing Tool" />
  <meta name="twitter:description" content="No cloud. No tracking. No logs. Just brutal API testing on your machine." />
  <meta name="twitter:image" content="https://rentgen.io/assets/og-image.png" />

  <link rel="stylesheet" href="../styles.css" />
</head>

<body>
  <header class="site-header">
    <div class="container header-inner">
      <a href="https://rentgen.io/#top" class="brand">
        <img src="../assets/rentgen-logo.png" class="brand-logo" />
        <span class="brand-name">Rentgen</span>
      </a>
      <button class="nav-toggle" aria-label="Toggle navigation">
        <span></span><span></span>
      </button>
      <nav class="site-nav">
        <a href="https://rentgen.io/#features">Features</a>
        <a href="https://rentgen.io/#security">Security</a>
        <a href="https://rentgen.io/#downloads">Downloads</a>
        <a href="https://rentgen.io/#cases">Case studies</a>
        <a href="https://rentgen.io/#github">GitHub</a>
        <a href="https://rentgen.io/api-stories/">API Stories</a>
      </nav>
    </div>
  </header>

  <main class="section">
    <article class="container article">
      <header class="article-header">
        <h1>Large Payload Handling — when <code>400</code> quietly opens the door to denial of service</h1>
        <p class="article-meta">
          Rentgen API Stories · January 2026
        </p>
      </header>

      <div class="article-content">
        <p>
          This is one of those bugs that looks harmless at first glance —
          until you realize it’s doing exactly the opposite of what the server
          should be protecting itself from.
        </p>

        <p>
          You send a very large payload.
          The API responds with <code>400 Bad Request</code>.
          Nothing crashes.
          No alerts fire.
          And everyone moves on.
        </p>

        <p>
          That response is wrong.
        </p>

        <h2>What was tested</h2>
        <p>
          Rentgen takes a known, valid API request and changes only one thing:
          the size of the request body.
        </p>

        <p>
          The payload is intentionally inflated beyond reasonable limits —
          without breaking JSON structure, headers, or authentication.
        </p>

        <ul>
          <li><strong>TEST:</strong> Large Payload Test</li>
          <li><strong>Mutation:</strong> Request body size increased (configurable)</li>
          <li><strong>Default size:</strong> 10 MB</li>
          <li><strong>Execution:</strong> Manual, isolated test via <code>Run</code> button</li>
          <li><strong>Expected:</strong> <code>413 Payload Too Large</code></li>
          <li><strong>Anything else:</strong> incorrect handling</li>
        </ul>

        <figure>
          <img width="100%" src="../assets/api-stories/large-payload-handling.png" alt="Uppercase Domain Test in Rentgen" />
          <figcaption>Rentgen mutates the host casing and checks whether the API stays stable</figcaption>
        </figure>

        <p>
          The test runs independently from the rest of the suite.
          You explicitly choose the payload size.
          The default is intentionally conservative.
        </p>

        <p>
          If your API accepts significantly more than that,
          it’s worth asking a very uncomfortable question:
          <em>why?</em>
        </p>

        <h2>The only correct response</h2>
        <p>
          HTTP already solved this problem.
        </p>

        <p>
          <code>413 Payload Too Large</code> exists for a reason:
          it tells the client that the request was well-formed,
          but rejected <em>before</em> processing due to size constraints.
        </p>

        <p>
          Returning <code>400 Bad Request</code> is misleading.
          It suggests invalid data.
          It implies the client should change the payload.
          And it often means the server already parsed far more than it should have.
        </p>

        <p>
          By the time a <code>400</code> is returned,
          the damage may already be done.
        </p>

        <h2>Why this matters</h2>
        <p>
          Large payload handling is not about user errors.
          It’s about protecting server resources.
        </p>

        <p>
          Accepting oversized requests — even briefly — means:
        </p>

        <ul>
          <li>memory allocation</li>
          <li>CPU time spent parsing</li>
          <li>threads tied up doing pointless work</li>
        </ul>

        <p>
          Multiply that by concurrent requests,
          and you have a denial-of-service vector
          that requires no authentication bypass,
          no malformed packets,
          and no exotic exploits.
        </p>

        <h2>What OWASP says</h2>
        <p>
          OWASP explicitly warns about uncontrolled resource consumption.
        </p>

        <p>
          Excessive payload sizes fall under multiple categories:
        </p>

        <ul>
          <li>Denial of Service (DoS)</li>
          <li>Unrestricted Resource Consumption</li>
          <li>Improper Input Validation</li>
        </ul>

        <p>
          The recommendation is simple:
          enforce strict size limits
          and reject oversized requests as early as possible.
        </p>

        <p>
          That rejection should happen at the boundary —
          not deep inside application logic.
        </p>

        <h2>The real-world example</h2>
        <p>
          This is not theoretical.
        </p>

        <p>
          Rentgen detected this exact issue in the ChatGPT API.
          Oversized payloads were accepted and processed incorrectly.
        </p>

        <p>
          The issue was reported.
          OpenAI fixed it within a day.
        </p>

        <p>
          That response speed tells you everything you need to know
          about the severity of the problem.
        </p>

        <h2>The debugging trap</h2>
        <p>
          Here’s how this bug usually hides:
        </p>

        <ul>
          <li>API works fine in normal conditions</li>
          <li>Clients never send huge payloads intentionally</li>
          <li>Load tests focus on request count, not size</li>
          <li>Error logs show nothing alarming</li>
        </ul>

        <p>
          Until someone — or something —
          starts sending very large bodies on purpose.
        </p>

        <p>
          At that point, the API doesn’t fail loudly.
          It just slows down.
          And then it stops responding.
        </p>

        <h2>What Rentgen found</h2>
        <p>
          In a correct implementation:
        </p>

        <ul>
          <li>
            Oversized payloads are rejected immediately
          </li>
          <li>
            No business logic is executed
          </li>
          <li>
            The response is explicit: <code>413 Payload Too Large</code>
          </li>
        </ul>

        <p>
          Anything else means the server is doing work
          it should never have started.
        </p>

        <h2>Why this bug survives</h2>
        <p>
          Because it hides behind “reasonable assumptions”.
        </p>

        <ul>
          <li>“Clients won’t send that much data”</li>
          <li>“We already validate input”</li>
          <li>“This endpoint isn’t public”</li>
        </ul>

        <p>
          None of those assumptions hold under attack.
        </p>

        <h2>How to fix it</h2>
        <p>
          The fix is boring.
          And that’s exactly why it works.
        </p>

        <ul>
          <li>Define strict payload size limits</li>
          <li>Enforce them at the edge (server, proxy, gateway)</li>
          <li>Return <code>413</code> consistently</li>
          <li>Document the limits</li>
        </ul>

        <p>
          This is not about flexibility.
          It’s about survival under pressure.
        </p>

        <h2>Why this check exists in Rentgen</h2>
        <p>
          Because this bug doesn’t announce itself.
        </p>

        <p>
          It waits quietly until someone decides
          to waste your resources on purpose.
        </p>

        <p>
          Rentgen runs this test explicitly
          so you can see the behavior
          before an attacker does.
        </p>

        <h2>Final thoughts</h2>
        <p>
          APIs don’t fall over only because of complex exploits.
        </p>

        <p>
          Sometimes they fall over
          because they were too polite to say:
          <em>“This payload is too large.”</em>
        </p>

        <p>
          If your API returns <code>413</code> consistently,
          you’re not being strict.
          You’re being responsible.
        </p>
      </div>
    </article>

  </main>

  <footer class="site-footer">
    <div class="container footer-inner">
      <span>© <span id="year"></span> Rentgen</span>
      <span class="footer-note">Built for testers, by a tester.</span>
    </div>
  </footer>

  <script src="../script.js"></script>
</body>
</html>
