<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>API Story: Cache-Control for Private API â€” preventing â€œghost dataâ€ in caches</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description"
    content="Rentgen is a secure, local-only API testing tool. No accounts, no tracking, no logging â€“ just deep backend tests that stay on your machine." />
  <link rel="canonical" href="https://rentgen.io/api-stories/reflected-payload-safety.html" />

  <!-- Favicon -->
  <link rel="icon" type="image/x-icon" href="../assets/favicon.ico" />
  <link rel="icon" type="image/png" href="../assets/rentgen-logo.png" />
  <link rel="apple-touch-icon" href="../assets/rentgen-logo.png" />

  <!-- Open Graph / Social -->
  <meta property="og:title" content="Rentgen â€“ Secure Local API Testing Tool" />
  <meta property="og:description" content="No cloud. No tracking. No logs. Just brutal API testing on your machine." />
  <meta property="og:image" content="https://rentgen.io/assets/og-image.png" />
  <meta property="og:url" content="https://rentgen.io/" />
  <meta property="og:type" content="website" />

  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="Rentgen â€“ Secure Local API Testing Tool" />
  <meta name="twitter:description" content="No cloud. No tracking. No logs. Just brutal API testing on your machine." />
  <meta name="twitter:image" content="https://rentgen.io/assets/og-image.png" />

  <link rel="stylesheet" href="../styles.css" />
</head>

<body>
  <header class="site-header">
    <div class="container header-inner">
      <a href="https://rentgen.io/#top" class="brand">
        <img src="../assets/rentgen-logo.png" class="brand-logo" />
        <span class="brand-name">Rentgen</span>
      </a>
      <button class="nav-toggle" aria-label="Toggle navigation">
        <span></span><span></span>
      </button>
      <nav class="site-nav">
        <a href="https://rentgen.io/#features">Features</a>
        <a href="https://rentgen.io/#security">Security</a>
        <a href="https://rentgen.io/#downloads">Downloads</a>
        <a href="https://rentgen.io/#cases">Case studies</a>
        <a href="https://rentgen.io/#github">GitHub</a>
        <a href="https://rentgen.io/api-stories/">API Stories</a>
      </nav>
    </div>
  </header>

  <main class="section">

    <article class="container article">
      <header class="article-header">
        <h1>Reflected Payload Safety â€” when your API turns an error into an XSS delivery service</h1>
        <p class="article-meta">
          Rentgen API Stories Â· January 2026
        </p>
      </header>

      <div class="article-content">
        <p>
          The fastest way to accidentally create a security problem is to be â€œhelpfulâ€.
          Especially in error messages.
          If your API mirrors user input back in the response (â€œyou sent <code>&lt;script&gt;...&lt;/script&gt;</code>â€),
          youâ€™re one bad UI decision away from shipping reflected XSS â€” even if your backend â€œonly returns JSONâ€.
        </p>

        <p>
          Rentgen has a simple rule:
          <strong>reject malicious-looking payloads</strong> and <strong>never echo them back</strong>.
          Not because developers are evil â€” but because developers are tired, and tired developers copy/paste.
        </p>

        <h2>What was tested</h2>
        <p>
          Rentgen injects a deliberately toxic payload into the request body:
        </p>

        <pre><code>{
      "body": "&lt;script&gt;alert(\"No XSS echo\")&lt;/script&gt;"
    }</code></pre>

        <p>
          Then it checks two things:
        </p>
        <ul>
          <li>
            <strong>Status code is honest:</strong> it should be <code>400 Bad Request</code> or
            <code>422 Unprocessable Entity</code> (anything else is suspicious for â€œyou sent nonsenseâ€).
          </li>
          <li>
            <strong>No mirrored content:</strong> the response body must not include the exact payload (or a sanitized-but-still-executable variant of it).
          </li>
        </ul>

        <figure>
          <img width="100%" src="../assets/api-stories/reflected-payload-safety.png" alt="Reflected Payload Safety check in Rentgen" />
          <figcaption>Rentgen rejects script-like payloads and verifies the API doesnâ€™t echo them back in error responses</figcaption>
        </figure>

        <h2>What Rentgen found</h2>
        <ul>
          <li><strong>TEST:</strong> Reflected Payload Safety</li>
          <li><strong>Expected:</strong> <code>400</code> or <code>422</code> + <strong>No Mirrored Content</strong></li>
          <li><strong>Actual:</strong> <code>400 Bad Request</code> + <strong>No Mirrored Content</strong></li>
          <li><strong>Result:</strong> <strong>ğŸŸ¢ Pass</strong></li>
        </ul>

        <h2>Why this test matters (even if you â€œreturn JSON onlyâ€)</h2>
        <p>
          â€œBut we donâ€™t render HTML.â€ Great. Your API still feeds systems that <em>do</em>:
          web apps, mobile WebViews, admin dashboards, observability tools, support portals, log viewers,
          and that one internal debug page someone threw together on Friday.
        </p>

        <p>
          Mirrored input becomes dangerous when any layer treats it as markup.
          Thatâ€™s literally how reflected cross-site scripting works: attacker-controlled input is reflected back and executed in a victimâ€™s context. :contentReference[oaicite:0]{index=0}
        </p>

        <p>
          OWASPâ€™s XSS guidance boils it down to a boring truth:
          untrusted data must be treated as untrusted â€” and you prevent execution through proper output encoding and safe handling.
          Echoing attacker input back is the opposite direction. 
        </p>

        <h2>The real-world â€œhow this bites youâ€ scenarios</h2>
        <ul>
          <li>
            <strong>Frontend shows API error message as HTML.</strong>
            Someone uses <code>innerHTML</code> (or a templating shortcut) to display
            <code>error.message</code> from the API. Your mirrored payload becomes executable.
          </li>
          <li>
            <strong>Admin/support dashboards render raw API responses.</strong>
            Support staff opens a â€œfailed request detailsâ€ page, and the payload executes in an authenticated back-office session.
          </li>
          <li>
            <strong>Logs become an attack surface.</strong>
            Many log viewers render and linkify. Some even allow HTML/markdown rendering.
            If mirrored input flows into logs, youâ€™ve created â€œstored XSS via logsâ€.
          </li>
          <li>
            <strong>Security teams lose trust instantly.</strong>
            Even if it doesnâ€™t pop XSS today, mirrored payloads in error responses are a bright red â€œyou donâ€™t control outputâ€ signal.
          </li>
        </ul>

        <h2>Why 400 or 422 specifically?</h2>
        <p>
          Because this isnâ€™t an authorization failure. It isnâ€™t a business rule issue.
          Itâ€™s malformed or unacceptable input.
          <code>400</code> says â€œyour request is invalidâ€. <code>422</code> says â€œyour structure is fine, your content isnâ€™tâ€.
          Both are defensible.
          Anything else starts lying about what happened:
        </p>
        <ul>
          <li><code>200</code> â€” you accepted nonsense (or your validation is theatre)</li>
          <li><code>500</code> â€” you let user input crash you (now itâ€™s reliability + security)</li>
          <li><code>401/403</code> â€” you turned bad input into auth noise</li>
        </ul>

        <h2>Why teams miss this</h2>
        <p>
          Because echoed input feels helpful during development.
          Itâ€™s the classic â€œweâ€™ll improve error messages laterâ€ trap.
          And later never comes â€” it ships as-is, gets copied across endpoints,
          and suddenly you have a consistent, well-engineered vulnerability pattern.
        </p>

        <p>
          Another reason: engineers assume JSON means â€œsafe by defaultâ€.
          Itâ€™s not. JSON is just a container.
          The moment something renders it, it becomes a UI problem â€” and UIs are where XSS lives.
        </p>

        <h2>How to fix it (pragmatic, not academic)</h2>
        <p>
          The fix is surprisingly simple:
          <strong>never reflect raw user input in error responses</strong>.
          If you must reference the field, do it without including attacker-controlled content.
        </p>

        <ul>
          <li>
            Prefer: <code>{"error":"Invalid request","field":"body","reason":"script tags are not allowed"}</code>
          </li>
          <li>
            Avoid: <code>{"error":"Invalid value: &lt;script&gt;...&lt;/script&gt;"}</code>
          </li>
          <li>
            If you need debugging:
            log the raw input <em>server-side</em> with safe storage and access control, not in the client response.
          </li>
        </ul>

        <h2>When is echoing safe?</h2>
        <p>
          Almost never in the response body.
          If youâ€™re absolutely sure the value will never be rendered (including by internal tools),
          you can argue itâ€™s â€œfineâ€.
          In practice, that certainty is a fantasy.
          The safer approach: donâ€™t echo it. Ever.
        </p>

        <h2>Why this check exists in Rentgen</h2>
        <p>
          Because Iâ€™ve seen it in the wild:
          an API rejects input, returns <em>the exact payload</em> in the error message,
          and then someone displays that message in a UI.
          Nobody planned an XSS exploit â€” it just happened through convenience.
        </p>

        <p>
          Rentgen doesnâ€™t care about your intent.
          It cares about the behavior:
          <strong>reject bad input</strong>, and <strong>donâ€™t mirror it back</strong>.
          If it passes â€” great, move on.
          If it fails â€” fix it once, and you kill an entire category of â€œoopsâ€ incidents.
        </p>

        <h2>Final thoughts</h2>
        <p>
          This is one of those tests that feels â€œsecurity-ishâ€ until you realize itâ€™s actually
          plain engineering hygiene.
          Your APIâ€™s error responses should be boring, consistent, and safe.
          Let the attacker shout into the void â€” not into your UI.
        </p>
      </div>
    </article>

  </main>

  <footer class="site-footer">
    <div class="container footer-inner">
      <span>Â© <span id="year"></span> Rentgen</span>
      <span class="footer-note">Built for testers, by a tester.</span>
    </div>
  </footer>

  <script src="../script.js"></script>
</body>
</html>
