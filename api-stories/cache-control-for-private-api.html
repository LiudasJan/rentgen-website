<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>API Story: Cache-Control for Private API â€” preventing â€œghost dataâ€ in caches</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description"
    content="Rentgen is a secure, local-only API testing tool. No accounts, no tracking, no logging â€“ just deep backend tests that stay on your machine." />
  <link rel="canonical" href="https://rentgen.io/api-stories/cache-control-for-private-api.html" />

  <!-- Favicon -->
  <link rel="icon" type="image/x-icon" href="../assets/favicon.ico" />
  <link rel="icon" type="image/png" href="../assets/rentgen-logo.png" />
  <link rel="apple-touch-icon" href="../assets/rentgen-logo.png" />

  <!-- Open Graph / Social -->
  <meta property="og:title" content="Rentgen â€“ Secure Local API Testing Tool" />
  <meta property="og:description" content="No cloud. No tracking. No logs. Just brutal API testing on your machine." />
  <meta property="og:image" content="https://rentgen.io/assets/og-image.png" />
  <meta property="og:url" content="https://rentgen.io/" />
  <meta property="og:type" content="website" />

  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="Rentgen â€“ Secure Local API Testing Tool" />
  <meta name="twitter:description" content="No cloud. No tracking. No logs. Just brutal API testing on your machine." />
  <meta name="twitter:image" content="https://rentgen.io/assets/og-image.png" />

  <link rel="stylesheet" href="../styles.css" />
</head>

<body>
  <header class="site-header">
    <div class="container header-inner">
      <a href="https://rentgen.io/#top" class="brand">
        <img src="../assets/rentgen-logo.png" class="brand-logo" />
        <span class="brand-name">Rentgen</span>
      </a>
      <button class="nav-toggle" aria-label="Toggle navigation">
        <span></span><span></span>
      </button>
      <nav class="site-nav">
        <a href="https://rentgen.io/#features">Features</a>
        <a href="https://rentgen.io/#security">Security</a>
        <a href="https://rentgen.io/#downloads">Downloads</a>
        <a href="https://rentgen.io/#cases">Case studies</a>
        <a href="https://rentgen.io/#github">GitHub</a>
        <a href="https://rentgen.io/api-stories/">API Stories</a>
      </nav>
    </div>
  </header>

  <main class="section">

    <article class="container article">
      <header class="article-header">
        <h1>Cache-Control for Private API â€” preventing â€œghost dataâ€ in caches</h1>
        <p class="article-meta">
          Rentgen API Stories Â· December 2025
        </p>
      </header>

      <div class="article-content">
        <p>
          HTTPS doesnâ€™t stop caching.
          It stops eavesdropping â€” but caching is your own browser, a mobile WebView, a corporate proxy,
          or a CDN edge quietly keeping copies of responses because thatâ€™s what caches do.
          And if your API returns anything private (tokens, PII, account data, internal IDs),
          a cached copy is basically data left behind.
        </p>

        <h2>What was tested</h2>
        <p>
          Rentgen checks responses from authenticated / private endpoints and verifies that caching is explicitly restricted.
          The expected baseline for private data is to see headers that clearly tell clients and intermediaries:
          <strong>do not store</strong> and <strong>do not share across users</strong>.
        </p>

        <figure>
          <img width="100%" src="../assets/api-stories/cache-control-private-api.png" alt="Cache-Control for Private API in Rentgen" />
          <figcaption>Rentgen verifies that private API responses are not cacheable</figcaption>
        </figure>

        <h2>What Rentgen found</h2>
        <ul>
          <li><strong>TEST:</strong> Cache-Control for Private API</li>
          <li><strong>Expected:</strong> <code>Cache-Control: no-store</code> and/or <code>private</code> (often with <code>no-cache</code>, <code>must-revalidate</code>)</li>
          <li><strong>Example result:</strong> <strong>ğŸŸ¢ Pass</strong> (<code>no-store, no-cache, must-revalidate</code>)</li>
          <li>
            <strong>If missing:</strong> Rentgen marks it as <strong>ğŸ”´ Fail</strong> â€” not a warning â€”
            because the impact is real and common: private responses become cacheable.
          </li>
        </ul>

        <h2>Why itâ€™s a fail (not a warning)</h2>
        <p>
          This isnâ€™t â€œnice-to-have hygieneâ€. It can become a real data exposure issue without any hacking.
          When a private response is cacheable, you can end up with sensitive data showing up later through normal behavior:
          a user logs out and hits Back, a shared machine reopens a page, a proxy serves a cached response, or a mobile app
          persists a response unintentionally.
        </p>

        <h2>Whatâ€™s the worst that can happen?</h2>
        <p>
          Not â€œsomeone runs a CVE exploitâ€. More boring. More painful:
        </p>
        <ul>
          <li><strong>Account data appears after logout</strong> (Back button, refresh, or cached views)</li>
          <li><strong>Tokens / identifiers linger</strong> in caches and logs on disk</li>
          <li><strong>PII sits in browser cache</strong> and turns into screenshots and incident reports</li>
        </ul>
        <p>
          This is why teams whoâ€™ve been burned treat caching headers as baseline security behavior,
          just like authentication and correct 4xx/5xx handling.
        </p>

        <h2>Who should take this seriously?</h2>
        <p>
          If your API returns anything user-specific, this matters:
          banking/fintech, healthcare, gov portals, internal admin tools, B2B dashboards â€”
          anything with sessions/cookies/bearer tokens, and anything returning names, emails, IDs, invoices, permissions, or reports.
          â€œInternal onlyâ€ doesnâ€™t save you. Internal leaks are still leaks.
        </p>

        <h2>When can you ignore it?</h2>
        <p>
          You can often relax strict no-store rules when the response is not sensitive and caching is intentional:
          public, non-auth endpoints; static reference data; public docs; public OpenAPI specs; version manifests that contain no secrets.
          But the moment itâ€™s authenticated and user-specific, treat caching like a loaded gun.
        </p>

        <h2>Why do many APIs still miss it?</h2>
        <p>
          Because itâ€™s not exciting. Itâ€™s not visible in UI. Nothing breaks.
          People assume â€œAPI-onlyâ€ means â€œno caching riskâ€, forget that browsers and proxies still exist,
          or rely on reverse proxies and gateways that override headers inconsistently.
          Another classic mistake: people think <code>no-cache</code> means â€œdonâ€™t storeâ€.
          It doesnâ€™t. It means â€œmust revalidate before reuseâ€.
        </p>

        <h2>How to fix it (the pragmatic default)</h2>
        <p>
          For private/authenticated endpoints returning sensitive data, a safe baseline is to explicitly disable caching.
          Typical configuration ends up with something like:
        </p>
        <ul>
          <li><code>Cache-Control: no-store, private</code></li>
          <li>often add: <code>no-cache, must-revalidate</code></li>
          <li>sometimes also: <code>Pragma: no-cache</code> and <code>Expires: 0</code> for legacy behavior</li>
        </ul>
        <p>
          The exact combo depends on your stack, but the intent is always the same:
          <strong>donâ€™t leave private data lying around</strong>.
        </p>

        <h2>Why I put this into Rentgen</h2>
        <p>
          Because people donâ€™t forget hard things. They forget simple, boring things â€” until a security review
          demonstrates â€œBack button shows private data after logoutâ€.
          Rentgen keeps this check enabled by default because itâ€™s fast to detect, easy to fix,
          and high impact when missed.
        </p>

        <h2>Final thoughts</h2>
        <p>
          If it passes: great â€” move on.
          If it fails: donâ€™t argue with it. Add the header and sleep better.
          This wonâ€™t make you feel like a superhero â€”
          but it will stop your API from leaving â€œghost dataâ€ behind where it doesnâ€™t belong.
        </p>
      </div>
    </article>


  </main>

  <footer class="site-footer">
    <div class="container footer-inner">
      <span>Â© <span id="year"></span> Rentgen</span>
      <span class="footer-note">Built for testers, by a tester.</span>
    </div>
  </footer>

  <script src="../script.js"></script>
</body>
</html>
