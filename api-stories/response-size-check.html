<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>API Story: Cache-Control for Private API ‚Äî preventing ‚Äúghost data‚Äù in caches</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description"
    content="Rentgen is a secure, local-only API testing tool. No accounts, no tracking, no logging ‚Äì just deep backend tests that stay on your machine." />
  <link rel="canonical" href="https://rentgen.io/api-stories/404-not-found-handling.html" />

  <!-- Favicon -->
  <link rel="icon" type="image/x-icon" href="../assets/favicon.ico" />
  <link rel="icon" type="image/png" href="../assets/rentgen-logo.png" />
  <link rel="apple-touch-icon" href="../assets/rentgen-logo.png" />

  <!-- Open Graph / Social -->
  <meta property="og:title" content="Rentgen ‚Äì Secure Local API Testing Tool" />
  <meta property="og:description" content="No cloud. No tracking. No logs. Just brutal API testing on your machine." />
  <meta property="og:image" content="https://rentgen.io/assets/og-image.png" />
  <meta property="og:url" content="https://rentgen.io/" />
  <meta property="og:type" content="website" />

  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="Rentgen ‚Äì Secure Local API Testing Tool" />
  <meta name="twitter:description" content="No cloud. No tracking. No logs. Just brutal API testing on your machine." />
  <meta name="twitter:image" content="https://rentgen.io/assets/og-image.png" />

  <link rel="stylesheet" href="../styles.css" />
</head>

<body>
  <header class="site-header">
    <div class="container header-inner">
      <a href="https://rentgen.io/#top" class="brand">
        <img src="../assets/rentgen-logo.png" class="brand-logo" />
        <span class="brand-name">Rentgen</span>
      </a>
      <button class="nav-toggle" aria-label="Toggle navigation">
        <span></span><span></span>
      </button>
      <nav class="site-nav">
        <a href="https://rentgen.io/#features">Features</a>
        <a href="https://rentgen.io/#security">Security</a>
        <a href="https://rentgen.io/#downloads">Downloads</a>
        <a href="https://rentgen.io/#cases">Case studies</a>
        <a href="https://rentgen.io/#github">GitHub</a>
        <a href="https://rentgen.io/api-stories/">API Stories</a>
      </nav>
    </div>
  </header>

  <main class="section">
    <article class="container article">
      <header class="article-header">
        <h1>Response Size Check ‚Äî when your API quietly starts returning garbage</h1>
        <p class="article-meta">
          Rentgen API Stories ¬∑ January 2026
        </p>
      </header>

      <div class="article-content">
        <p>
          Large API responses almost never look like bugs at first.
          The endpoint works. The JSON is valid. The client receives data.
          Nothing crashes.
        </p>

        <p>
          And that‚Äôs exactly why oversized responses survive for months ‚Äî sometimes years ‚Äî
          until performance degrades, mobile clients suffer, and nobody remembers how it started.
        </p>

        <h2>What was tested</h2>
        <p>
          Rentgen observes response sizes during normal test execution.
          No special load, no synthetic requests.
          If <strong>any single JSON response</strong> exceeds <code>100 KB</code>,
          the test is marked as failed.
        </p>

        <p>
          This is intentionally strict.
          Returning megabyte-sized JSON payloads is almost never a good default ‚Äî
          especially for APIs consumed by web or mobile clients.
        </p>

        <figure>
          <img width="100%" src="../assets/api-stories/ping-latency.png" alt="Response Size Check detecting oversized JSON payload" />
          <figcaption>Rentgen detects excessive response sizes during normal API execution</figcaption>
        </figure>

        <h2>What Rentgen found</h2>
        <ul>
          <li><strong>TEST:</strong> Response Size Check</li>
          <li><strong>Expected:</strong> JSON response size <code>&lt; 100 KB</code></li>
          <li><strong>Actual:</strong> <code>1536.21 KB</code></li>
          <li><strong>Status:</strong> <strong>üî¥ Fail</strong></li>
        </ul>

        <h2>Why this is a real problem</h2>
        <p>
          Returning large JSON responses is rarely intentional.
          It usually indicates poor API design decisions that accumulated quietly:
          overfetching, missing pagination, missing filtering, or internal data leaking into public responses.
        </p>

        <p>
          The real damage is not theoretical.
          Large responses create very real problems:
        </p>

        <ul>
          <li>slower response times, especially on mobile networks</li>
          <li>high memory usage on clients</li>
          <li>slower JSON parsing and rendering</li>
          <li>increased bandwidth costs</li>
          <li>fragile clients tightly coupled to oversized payloads</li>
        </ul>

        <p>
          Client-side pagination does not solve this.
          By the time the client paginates, the damage is already done ‚Äî
          the data has been transferred, parsed, and allocated in memory.
        </p>

        <h2>Why nobody notices this during manual testing</h2>
        <p>
          Because manual testing focuses on correctness, not scale.
          A tester sends a request, sees data, and moves on.
          A developer checks a response in Postman and thinks: ‚ÄúLooks fine.‚Äù
        </p>

        <p>
          Nobody scrolls through a 1.5 MB JSON payload and thinks:
          ‚ÄúThis will destroy mobile performance in six months.‚Äù
        </p>

        <p>
          By the time it becomes obvious, the response shape is already depended on by clients,
          making it painful and risky to change.
        </p>

        <h2>Why this turns into a future disaster</h2>
        <p>
          Oversized responses tend to grow, not shrink.
          New fields get added.
          Nested objects expand.
          ‚ÄúTemporary‚Äù debug data becomes permanent.
        </p>

        <p>
          Eventually teams are forced to optimize under pressure:
          caching hacks, partial rewrites, breaking changes, or emergency pagination retrofits.
          All of this could have been avoided by catching the problem early.
        </p>

        <h2>How Rentgen helps</h2>
        <p>
          Rentgen catches oversized responses automatically,
          during normal test execution.
          You don‚Äôt need to inspect payloads manually or remember to check sizes.
        </p>

        <p>
          When the check fails, Rentgen provides a ready-to-copy bug report
          that explains the impact, shows the measured response size,
          and suggests concrete design-level fixes.
          The goal is not blame ‚Äî the goal is early correction.
        </p>

        <h2>What a healthy API does instead</h2>
        <p>
          Well-designed APIs return minimal, intentional data by default.
          Large datasets are handled explicitly through pagination, filtering,
          and expansion parameters.
        </p>

        <p>
          If a response ‚Äúlooks big‚Äù, it probably is.
          And if it is big today, it will be worse tomorrow.
        </p>

        <h2>Final thoughts</h2>
        <p>
          Response size is not a cosmetic metric.
          It is a design signal.
        </p>

        <p>
          Rentgen checks it because once oversized payloads reach production,
          they are expensive to undo.
          Catching them early saves performance, money, and future arguments.
        </p>
      </div>
    </article>

  </main>

  <footer class="site-footer">
    <div class="container footer-inner">
      <span>¬© <span id="year"></span> Rentgen</span>
      <span class="footer-note">Built for testers, by a tester.</span>
    </div>
  </footer>

  <script src="../script.js"></script>
</body>
</html>
