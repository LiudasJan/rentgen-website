<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>API Stories – Rentgen</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description"
    content="Rentgen is a secure, local-only API testing tool. No accounts, no tracking, no logging – just deep backend tests that stay on your machine." />
  <link rel="canonical" href="https://rentgen.io/api-stories/index.html" />

  <!-- Favicon -->
  <link rel="icon" type="image/x-icon" href="../assets/favicon.ico" />
  <link rel="icon" type="image/png" href="../assets/rentgen-logo.png" />
  <link rel="apple-touch-icon" href="../assets/rentgen-logo.png" />

  <!-- Open Graph / Social -->
  <meta property="og:title" content="Rentgen – Secure Local API Testing Tool" />
  <meta property="og:description" content="No cloud. No tracking. No logs. Just brutal API testing on your machine." />
  <meta property="og:image" content="https://rentgen.io/assets/og-image.png" />
  <meta property="og:url" content="https://rentgen.io/" />
  <meta property="og:type" content="website" />

  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="Rentgen – Secure Local API Testing Tool" />
  <meta name="twitter:description" content="No cloud. No tracking. No logs. Just brutal API testing on your machine." />
  <meta name="twitter:image" content="https://rentgen.io/assets/og-image.png" />

  <link rel="stylesheet" href="../styles.css" />
</head>

<body>
  <header class="site-header">
    <div class="container header-inner">
      <a href="https://rentgen.io/#top" class="brand">
        <img src="../assets/rentgen-logo.png" class="brand-logo" alt="Rentgen logo" />
        <span class="brand-name">Rentgen</span>
      </a>
    <button class="nav-toggle" aria-label="Toggle navigation">
        <span></span><span></span>
      </button>
      <nav class="site-nav">
        <a href="https://rentgen.io/#features">Features</a>
        <a href="https://rentgen.io/#security">Security</a>
        <a href="https://rentgen.io/#downloads">Downloads</a>
        <a href="https://rentgen.io/#cases">Case studies</a>
        <a href="https://rentgen.io/#github">GitHub</a>
        <a href="https://rentgen.io/api-stories/">API Stories</a>
      </nav>
    </div>
  </header>

  <main class="section">
    <div class="container">
      <header class="section-header">
        <h1>Rentgen API Stories</h1>
        <p>
          This is not a company blog.
          We don’t publish feature announcements, roadmaps, or “10 tips to improve your API”.
          Real-world API behaviour, exposed.
          Not tutorials. Not mock data. Not perfect examples.
          Just real APIs doing unexpected things under pressure.
        </p>
      </header>

      <div class="story-list">

        <article class="story-card">
          <h3>Rentgen is not a Postman replacement — it fills the gap Postman never tried to fill</h3>
            <p>
              If you live in Postman — writing scripts, crafting assertions, maintaining collections for CI,
              debugging runners at 1 a.m. — then Rentgen is not competing with that.
              Rentgen exists <strong>before</strong> all of that.
            </p>
          <a href="./rentgen-not-a-postman-replacement.html" class="case-link">
            Read story →
          </a>
        </article>

        <article class="story-card">
          <h3>Uppercase Domain Handling — why LOCALHOST should not crash your API</h3>
          <p>
            Uppercase domains are rare but real.
            When APIs fail on <code>API.EXAMPLE.COM</code> or <code>LOCALHOST</code>,
            the issue is usually hidden in proxies, routing rules, or local dev setups —
            and almost never covered by tests.
          </p>
          <a href="./uppercase-domain-handling.html" class="case-link">
            Read story →
          </a>
        </article>

        <article class="story-card">
          <h3>Reflected Payload Safety — how helpful errors quietly create vulnerabilities</h3>
          <p>
            Echoing user input in API error responses feels useful during development,
            but it creates long-term risk.
            One copied error message, one careless UI render —
            and your validation logic becomes a delivery mechanism.
          </p>
          <a href="./reflected-payload-safety.html" class="case-link">
            Read story →
          </a>
        </article>

        <article class="story-card">
          <h3>404 Not Found Handling — how broken URLs silently waste engineering time</h3>
          <p>
            When non-existent endpoints return <code>200 OK</code>,
            APIs lie to their clients and dashboards lie to engineers.
            Errors disappear from monitoring,
            while users and partners keep hitting URLs that should never exist.
          </p>
          <a href="./404-not-found-handling.html" class="case-link">
            Read story →
          </a>
        </article>


        <article class="story-card">
          <h3>CORS Policy Check — when nobody knows who your API is for</h3>
          <p>
            Overly permissive or overly restrictive CORS settings are rarely intentional.
            They usually come from copy-paste defaults and forgotten decisions,
            leaving teams with APIs that work in curl but fail in browsers
            and integrations that were never meant to be blocked.
          </p>
          <a href="./cors-policy-check.html" class="case-link">
            Read story →
          </a>
        </article>

        <article class="story-card">
          <h3>Missing Authorization Handling — when your API sends you in the wrong direction</h3>
          <p>
            When authentication is missing, the only honest response is <code>401 Unauthorized</code>.
            Returning <code>403 Forbidden</code> or <code>400 Bad Request</code> misleads clients,
            turns simple mistakes into long debugging sessions,
            and makes developers question everything except the real problem.
          </p>
          <a href="./missing-authorization-handling.html" class="case-link">
            Read story →
          </a>
        </article>

        <article class="story-card">
          <h3>Unsupported HTTP Method Handling — when debugging starts with a lie</h3>
          <p>
            Returning <code>200 OK</code> for an unsupported HTTP method breaks trust.
            Instead of a clear signal like <code>405 Method Not Allowed</code>,
            clients get silence — and engineers waste time debugging payloads
            when the real problem is simply the wrong method.
          </p>
          <a href="./unsupported-http-method-handling.html" class="case-link">
            Read story →
          </a>
        </article>


        <article class="story-card">
          <h3>OPTIONS Method Handling — when your API rejects capability discovery</h3>
          <p>
            <code>OPTIONS</code> isn’t “extra”. It’s how clients and browsers ask what an endpoint allows.
            If your API answers a valid <code>OPTIONS</code> request with <code>400 Bad Request</code>,
            you risk broken CORS preflights, confusing client behavior, and a REST API that doesn’t speak HTTP properly.
          </p>
          <a href="./options-method-handling.html" class="case-link">
            Read story →
          </a>
        </article>

        <article class="story-card">
          <h3>Cache-Control for Private API — preventing “ghost data” in caches</h3>
          <p>
            HTTPS doesn’t stop browsers, proxies, or devices from caching responses.
            Without explicit Cache-Control rules, private API data can quietly persist
            after logout, across sessions, or even across users —
            turning normal behavior into a data exposure risk.
          </p>
          <a href="./cache-control-for-private-api.html" class="case-link">
            Read story →
          </a>
        </article>

        <article class="story-card">
          <h3>MIME Sniffing Protection — when the browser decides what your API response really is</h3>
          <p>
            APIs assume clients respect Content-Type.
            Browsers don’t always agree.
            Without X-Content-Type-Options: nosniff, a response meant to be data
            can be reinterpreted as executable content — quietly turning a harmless API into an attack surface.
          </p>
          <a href="./mime-sniffing-protection.html" class="case-link">
            Read story →
          </a>
        </article>


        <article class="story-card">
          <h3>HSTS (Strict-Transport-Security) — preventing silent HTTP downgrade</h3>
          <p>
            HTTPS alone doesn’t guarantee safety.
            Without HSTS, clients may still accept HTTP during redirects or first contact.
            It’s not a breaking issue — but it quietly weakens transport security
            in exactly the places attackers like.
          </p>
          <a href="./hsts-strict-transport-security.html" class="case-link">
            Read story →
          </a>
        </article>


        <article class="story-card">
          <h3>Clickjacking Protection — when users click something they never intended</h3>
          <p>
            Clickjacking isn’t about broken APIs or crashing systems.
            It’s about valid actions executed through invisible frames.
            Missing X-Frame-Options or CSP frame-ancestors doesn’t look dangerous —
            until a real user clicks “Approve” on a page they can’t even see.
          </p>
          <a href="./clickjacking-protection.html" class="case-link">
            Read story →
          </a>
        </article>


        <article class="story-card">
          <h3>Server Header Does Not Expose Version — the simplest security check everyone forgets</h3>
          <p>
            Sometimes security fails not because things are hard,
            but because they are boring.
            Exposing your server version in response headers is one of those
            tiny details that quietly helps attackers —
            and quietly slips through reviews.
          </p>
          <a href="./server-header-does-not-expose-version.html" class="case-link">
            Read story →
          </a>
        </article>


        <article class="story-card">
          <h3>What a real Jira API request reveals under Rentgen testing</h3>
          <p>
            Jira is one of the most trusted developer tools in the industry.
            We took a real ticket creation request, ran it through Rentgen,
            and looked at how the API behaves under invalid input, edge cases,
            and load — no theory, just reality.
          </p>
          <a href="./jira-api-testing-with-rentgen.html" class="case-link">
            Read story →
          </a>
        </article>

        <article class="story-card">
          <h3>REST Clients vs API Testing</h3>
            <p>
              REST clients help you send requests.
              API testing tools help you understand whether your API is actually good.
              Most people confuse these two.
            </p>
          <a href="./rest-clients-vs-api-testing.html" class="case-link">
            Read story →
          </a>
        </article>

      </div>
    </div>
  </main>

  <footer class="site-footer">
    <div class="container footer-inner">
      <span>© <span id="year"></span> Rentgen</span>
      <span class="footer-note">Built for testers, by a tester.</span>
    </div>
  </footer>

  <script src="../script.js"></script>
</body>
</html>
