<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>API Stories – Rentgen</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description"
    content="Rentgen is a secure, local-only API testing tool. No accounts, no tracking, no logging – just deep backend tests that stay on your machine." />
  <link rel="canonical" href="https://rentgen.io/api-stories/index.html" />

  <!-- Favicon -->
  <link rel="icon" type="image/x-icon" href="../assets/favicon.ico" />
  <link rel="icon" type="image/png" href="../assets/rentgen-logo.png" />
  <link rel="apple-touch-icon" href="../assets/rentgen-logo.png" />

  <!-- Open Graph / Social -->
  <meta property="og:title" content="Rentgen – Secure Local API Testing Tool" />
  <meta property="og:description" content="No cloud. No tracking. No logs. Just brutal API testing on your machine." />
  <meta property="og:image" content="https://rentgen.io/assets/og-image.png" />
  <meta property="og:url" content="https://rentgen.io/" />
  <meta property="og:type" content="website" />

  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="Rentgen – Secure Local API Testing Tool" />
  <meta name="twitter:description" content="No cloud. No tracking. No logs. Just brutal API testing on your machine." />
  <meta name="twitter:image" content="https://rentgen.io/assets/og-image.png" />

  <link rel="stylesheet" href="../styles.css" />
</head>

<body>
  <header class="site-header">
    <div class="container header-inner">
      <a href="https://rentgen.io/#top" class="brand">
        <img src="../assets/rentgen-logo.png" class="brand-logo" alt="Rentgen logo" />
        <span class="brand-name">Rentgen</span>
      </a>
    <button class="nav-toggle" aria-label="Toggle navigation">
        <span></span><span></span>
      </button>
      <nav class="site-nav">
        <a href="https://rentgen.io/#features">Features</a>
        <a href="https://rentgen.io/#security">Security</a>
        <a href="https://rentgen.io/#downloads">Downloads</a>
        <a href="https://rentgen.io/#cases">Case studies</a>
        <a href="https://rentgen.io/#github">GitHub</a>
        <a href="https://rentgen.io/api-stories/">API Stories</a>
        <a href="https://rentgen.io/dedicated/">Dedicated Rentgen </a>
      </nav>
    </div>
  </header>

  <main class="section">
    <div class="container">
      <header class="section-header">
        <h1>Rentgen API Stories</h1>
        <p>
          This is not a company blog.
          We don’t publish feature announcements, roadmaps, or “10 tips to improve your API”.
          Real-world API behaviour, exposed.
          Not tutorials. Not mock data. Not perfect examples.
          Just real APIs doing unexpected things under pressure.
        </p>
      </header>

      <div class="story-list">

        <article class="story-card">
          <h3>Rentgen is not a Postman replacement — it fills the gap Postman never tried to fill</h3>
            <p>
              If you live in Postman — writing scripts, crafting assertions, maintaining collections for CI,
              debugging runners at 1 a.m. — then Rentgen is not competing with that.
              Rentgen exists <strong>before</strong> all of that.
            </p>
          <a href="./rentgen-not-a-postman-replacement.html" class="case-link">
            Read story →
          </a>
        </article>

        <article class="story-card">
          <h3>Telemetry Input Validation — when ChatGPT crashes on malformed data</h3>
          <p>
            We pointed Rentgen at a real ChatGPT telemetry endpoint and triggered
            <strong>500 Internal Server Errors</strong> using nothing but malformed input.
            No fuzzing, no guessing — just a copied cURL and one mutated field.
          </p>
          <a href="./ChatGPT-when-malformed-data-crashes-a-non-critical-API.html" class="case-link">
            Read story →
          </a>
        </article>

        <article class="story-card">
          <h3>Built-in Boundary Value Analysis — the bugs hiding at the edges</h3>
          <p>
            Boundary value analysis is one of the most effective testing techniques —
            and one of the easiest to forget.
            Rentgen makes it impossible to skip by generating boundary tests
            automatically from your API input definitions.
          </p>
          <a href="./boundary-value-analysis.html" class="case-link">
            Read story →
          </a>
        </article>

        <article class="story-card">
          <h3>Trimming Test — when one invisible space creates two “unique” records</h3>
          <p>
            Trimming is a small check that causes big integration failures when ignored.
            Rentgen detects whether your API normalizes string input or silently accepts
            leading and trailing whitespace that later breaks uniqueness and client assumptions.
          </p>
          <a href="./trimming-test.html" class="case-link">
            Read story →
          </a>
        </article>

        <article class="story-card">
          <h3>Built-in Load Test — when a little concurrency already bends your API</h3>
          <p>
            Rentgen includes a lightweight load test built directly into API testing.
            With just a few parallel requests, it reveals performance degradation
            long before real traffic hits production.
          </p>
          <a href="./load-test.html" class="case-link">
            Read story →
          </a>
        </article>

        <article class="story-card">
          <h3>Array List Without Pagination — when “it won’t grow” inevitably does</h3>
          <p>
            Rentgen flags GET endpoints that return JSON arrays without pagination or limits.
            It’s not a functional bug yet — but it’s a classic design risk that quietly turns into
            performance problems and client failures as data grows.
          </p>
          <a href="./array-list-without-pagination.html" class="case-link">
            Read story →
          </a>
        </article>

        <article class="story-card">
          <h3>Response Size Check — when your API returns way too much</h3>
          <p>
            Rentgen detects oversized JSON responses automatically.
            If a single response exceeds <code>100 KB</code>, it’s a clear sign of overfetching,
            missing pagination, or leaking internal data — problems that usually go unnoticed until it’s too late.
          </p>
          <a href="./response-size-check.html" class="case-link">
            Read story →
          </a>
        </article>

        <article class="story-card">
          <h3>Network Share Calculation — when latency comes from the wire, not the API</h3>
          <p>
            Rentgen calculates how much of the total response time is pure network latency.
            When ping consumes a large share of the response, backend optimization won’t help —
            the problem is distance, routing, or too many hops.
          </p>
          <a href="./network-share-calculation.html" class="case-link">
            Read story →
          </a>
        </article>

        <article class="story-card">
          <h3>Ping Latency — when your performance numbers stop making sense</h3>
          <p>
            Rentgen treats ping as a baseline signal, not a curiosity.
            If network latency exceeds <code>100 ms</code> in a nearby environment,
            response time metrics become unreliable — and performance analysis starts from the wrong place.
          </p>
          <a href="./ping-latency.html" class="case-link">
            Read story →
          </a>
        </article>

        <article class="story-card">
          <h3>Performance Insights — when median response time tells the truth</h3>
          <p>
            Rentgen doesn’t run load tests.
            It sends real requests one by one — and still measures how your API responds.
            If the median response time exceeds <code>500 ms</code> without any load,
            something is already wrong.
          </p>
          <a href="./performance-insights-median-response-time.html" class="case-link">
            Read story →
          </a>
        </article>

        <article class="story-card">
          <h3>Large Payload Handling — when <code>400</code> quietly enables denial of service</h3>
          <p>
            Oversized requests should be rejected immediately.
            If your API responds with <code>400 Bad Request</code> instead of a clear
            <code>413 Payload Too Large</code>, it may already be parsing and allocating
            resources — opening the door to trivial DoS attacks.
          </p>
          <a href="./large-payload-handling.html" class="case-link">
            Read story →
          </a>
        </article>

        <article class="story-card">
          <h3>Uppercase Path Handling — when <code>/V1</code> wastes half your day</h3>
          <p>
            URL paths are usually case-sensitive.
            If your API responds with <code>400</code> or <code>500</code> instead of a clear <code>404</code>,
            developers end up debugging payloads and auth —
            when the real problem is just one uppercase letter.
          </p>
          <a href="./uppercase-path-handling.html" class="case-link">
            Read story →
          </a>
        </article>

        <article class="story-card">
          <h3>Uppercase Domain Handling — why LOCALHOST should not crash your API</h3>
          <p>
            Uppercase domains are rare but real.
            When APIs fail on <code>API.EXAMPLE.COM</code> or <code>LOCALHOST</code>,
            the issue is usually hidden in proxies, routing rules, or local dev setups —
            and almost never covered by tests.
          </p>
          <a href="./uppercase-domain-handling.html" class="case-link">
            Read story →
          </a>
        </article>

        <article class="story-card">
          <h3>Reflected Payload Safety — how helpful errors quietly create vulnerabilities</h3>
          <p>
            Echoing user input in API error responses feels useful during development,
            but it creates long-term risk.
            One copied error message, one careless UI render —
            and your validation logic becomes a delivery mechanism.
          </p>
          <a href="./reflected-payload-safety.html" class="case-link">
            Read story →
          </a>
        </article>

        <article class="story-card">
          <h3>404 Not Found Handling — how broken URLs silently waste engineering time</h3>
          <p>
            When non-existent endpoints return <code>200 OK</code>,
            APIs lie to their clients and dashboards lie to engineers.
            Errors disappear from monitoring,
            while users and partners keep hitting URLs that should never exist.
          </p>
          <a href="./404-not-found-handling.html" class="case-link">
            Read story →
          </a>
        </article>


        <article class="story-card">
          <h3>CORS Policy Check — when nobody knows who your API is for</h3>
          <p>
            Overly permissive or overly restrictive CORS settings are rarely intentional.
            They usually come from copy-paste defaults and forgotten decisions,
            leaving teams with APIs that work in curl but fail in browsers
            and integrations that were never meant to be blocked.
          </p>
          <a href="./cors-policy-check.html" class="case-link">
            Read story →
          </a>
        </article>

        <article class="story-card">
          <h3>Missing Authorization Handling — when your API sends you in the wrong direction</h3>
          <p>
            When authentication is missing, the only honest response is <code>401 Unauthorized</code>.
            Returning <code>403 Forbidden</code> or <code>400 Bad Request</code> misleads clients,
            turns simple mistakes into long debugging sessions,
            and makes developers question everything except the real problem.
          </p>
          <a href="./missing-authorization-handling.html" class="case-link">
            Read story →
          </a>
        </article>

        <article class="story-card">
          <h3>Unsupported HTTP Method Handling — when debugging starts with a lie</h3>
          <p>
            Returning <code>200 OK</code> for an unsupported HTTP method breaks trust.
            Instead of a clear signal like <code>405 Method Not Allowed</code>,
            clients get silence — and engineers waste time debugging payloads
            when the real problem is simply the wrong method.
          </p>
          <a href="./unsupported-http-method-handling.html" class="case-link">
            Read story →
          </a>
        </article>


        <article class="story-card">
          <h3>OPTIONS Method Handling — when your API rejects capability discovery</h3>
          <p>
            <code>OPTIONS</code> isn’t “extra”. It’s how clients and browsers ask what an endpoint allows.
            If your API answers a valid <code>OPTIONS</code> request with <code>400 Bad Request</code>,
            you risk broken CORS preflights, confusing client behavior, and a REST API that doesn’t speak HTTP properly.
          </p>
          <a href="./options-method-handling.html" class="case-link">
            Read story →
          </a>
        </article>

        <article class="story-card">
          <h3>Cache-Control for Private API — preventing “ghost data” in caches</h3>
          <p>
            HTTPS doesn’t stop browsers, proxies, or devices from caching responses.
            Without explicit Cache-Control rules, private API data can quietly persist
            after logout, across sessions, or even across users —
            turning normal behavior into a data exposure risk.
          </p>
          <a href="./cache-control-for-private-api.html" class="case-link">
            Read story →
          </a>
        </article>

        <article class="story-card">
          <h3>MIME Sniffing Protection — when the browser decides what your API response really is</h3>
          <p>
            APIs assume clients respect Content-Type.
            Browsers don’t always agree.
            Without X-Content-Type-Options: nosniff, a response meant to be data
            can be reinterpreted as executable content — quietly turning a harmless API into an attack surface.
          </p>
          <a href="./mime-sniffing-protection.html" class="case-link">
            Read story →
          </a>
        </article>


        <article class="story-card">
          <h3>HSTS (Strict-Transport-Security) — preventing silent HTTP downgrade</h3>
          <p>
            HTTPS alone doesn’t guarantee safety.
            Without HSTS, clients may still accept HTTP during redirects or first contact.
            It’s not a breaking issue — but it quietly weakens transport security
            in exactly the places attackers like.
          </p>
          <a href="./hsts-strict-transport-security.html" class="case-link">
            Read story →
          </a>
        </article>


        <article class="story-card">
          <h3>Clickjacking Protection — when users click something they never intended</h3>
          <p>
            Clickjacking isn’t about broken APIs or crashing systems.
            It’s about valid actions executed through invisible frames.
            Missing X-Frame-Options or CSP frame-ancestors doesn’t look dangerous —
            until a real user clicks “Approve” on a page they can’t even see.
          </p>
          <a href="./clickjacking-protection.html" class="case-link">
            Read story →
          </a>
        </article>


        <article class="story-card">
          <h3>Server Header Does Not Expose Version — the simplest security check everyone forgets</h3>
          <p>
            Sometimes security fails not because things are hard,
            but because they are boring.
            Exposing your server version in response headers is one of those
            tiny details that quietly helps attackers —
            and quietly slips through reviews.
          </p>
          <a href="./server-header-does-not-expose-version.html" class="case-link">
            Read story →
          </a>
        </article>


        <article class="story-card">
          <h3>What a real Jira API request reveals under Rentgen testing</h3>
          <p>
            Jira is one of the most trusted developer tools in the industry.
            We took a real ticket creation request, ran it through Rentgen,
            and looked at how the API behaves under invalid input, edge cases,
            and load — no theory, just reality.
          </p>
          <a href="./jira-api-testing-with-rentgen.html" class="case-link">
            Read story →
          </a>
        </article>

        <article class="story-card">
          <h3>REST Clients vs API Testing</h3>
            <p>
              REST clients help you send requests.
              API testing tools help you understand whether your API is actually good.
              Most people confuse these two.
            </p>
          <a href="./rest-clients-vs-api-testing.html" class="case-link">
            Read story →
          </a>
        </article>

      </div>
    </div>
  </main>

  <footer class="site-footer">
    <div class="container footer-inner">
      <span>© <span id="year"></span> Rentgen</span>
      <span class="footer-note">Built for testers, by a tester.</span>
    </div>
  </footer>

  <script src="../script.js"></script>
</body>
</html>
