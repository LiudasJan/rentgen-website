<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>API Story: Cache-Control for Private API — preventing “ghost data” in caches</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description"
    content="Rentgen is a secure, local-only API testing tool. No accounts, no tracking, no logging – just deep backend tests that stay on your machine." />
  <link rel="canonical" href="https://rentgen.io/api-stories/performance-insights-median-response-time.html" />

  <!-- Favicon -->
  <link rel="icon" type="image/x-icon" href="../assets/favicon.ico" />
  <link rel="icon" type="image/png" href="../assets/rentgen-logo.png" />
  <link rel="apple-touch-icon" href="../assets/rentgen-logo.png" />

  <!-- Open Graph / Social -->
  <meta property="og:title" content="Rentgen – Secure Local API Testing Tool" />
  <meta property="og:description" content="No cloud. No tracking. No logs. Just brutal API testing on your machine." />
  <meta property="og:image" content="https://rentgen.io/assets/og-image.png" />
  <meta property="og:url" content="https://rentgen.io/" />
  <meta property="og:type" content="website" />

  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="Rentgen – Secure Local API Testing Tool" />
  <meta name="twitter:description" content="No cloud. No tracking. No logs. Just brutal API testing on your machine." />
  <meta name="twitter:image" content="https://rentgen.io/assets/og-image.png" />

  <link rel="stylesheet" href="../styles.css" />
</head>

<body>
  <header class="site-header">
    <div class="container header-inner">
      <a href="https://rentgen.io/#top" class="brand">
        <img src="../assets/rentgen-logo.png" class="brand-logo" />
        <span class="brand-name">Rentgen</span>
      </a>
      <button class="nav-toggle" aria-label="Toggle navigation">
        <span></span><span></span>
      </button>
      <nav class="site-nav">
        <a href="https://rentgen.io/#features">Features</a>
        <a href="https://rentgen.io/#security">Security</a>
        <a href="https://rentgen.io/#downloads">Downloads</a>
        <a href="https://rentgen.io/#cases">Case studies</a>
        <a href="https://rentgen.io/#github">GitHub</a>
        <a href="https://rentgen.io/api-stories/">API Stories</a>
      </nav>
    </div>
  </header>

  <main class="section">

    <article class="container article">
      <header class="article-header">
        <h1>Performance Insights — when median response time quietly tells the truth</h1>
        <p class="article-meta">
          Rentgen API Stories · January 2026
        </p>
      </header>

      <div class="article-content">
        <p>
          When testing API functionality, performance is usually treated as
          “someone else’s problem”.
          Functional testing uses one set of tools.
          Performance testing uses another.
        </p>

        <p>
          Or at least, that was true before Rentgen.
        </p>

        <p>
          Because once you start generating dozens or hundreds of real requests —
          not synthetic benchmarks, not isolated pings —
          performance stops being a separate concern.
          It becomes visible by default.
        </p>

        <h2>What this test is — and what it is not</h2>

        <figure>
          <img width="100%" src="../assets/api-stories/performance-insights-median-response-time.png" alt="OPTIONS Method Handling in Rentgen" />
          <figcaption>Rentgen tells you what a “typical” request actually experiences</figcaption>
        </figure>

        <p>
          Rentgen is not a load testing tool.
          It does not try to overwhelm your API.
          Requests are sent one by one, intentionally.
        </p>

        <p>
          The goal is not to break the system.
          The goal is to observe how it behaves under normal, varied usage:
        </p>

        <ul>
          <li>valid requests</li>
          <li>edge cases</li>
          <li>negative flows</li>
          <li>unexpected input combinations</li>
        </ul>

        <p>
          While doing that, Rentgen measures response times
          and builds a simple but telling metric:
          <strong>median response time</strong>.
        </p>

        <h2>What was tested</h2>
        <p>
          Rentgen executes a large set of generated API requests
          derived from a single known-good cURL.
        </p>

        <p>
          Each request is timed.
          The median response time is calculated across the full run.
        </p>

        <ul>
          <li><strong>TEST:</strong> Median Response Time</li>
          <li><strong>Execution:</strong> sequential requests (no concurrency)</li>
          <li><strong>Expected:</strong> ≤ <code>500 ms</code></li>
          <li><strong>Fail condition:</strong> median &gt; <code>500 ms</code></li>
        </ul>

        <p>
          This threshold is intentionally conservative.
          If your API cannot respond consistently under 500 ms
          without any load pressure,
          something is already wrong.
        </p>

        <h2>Why median matters</h2>
        <p>
          Averages lie.
        </p>

        <p>
          One fast response can hide several slow ones.
          One cached response can mask deeper problems.
        </p>

        <p>
          Median response time cuts through that noise.
          It tells you what a “typical” request actually experiences.
        </p>

        <p>
          If the median is slow,
          the API is slow — even if some requests look fine.
        </p>

        <h2>Why this matters even without load</h2>
        <p>
          A slow API without load is a bigger red flag
          than a slow API under pressure.
        </p>

        <p>
          It usually means:
        </p>

        <ul>
          <li>inefficient queries</li>
          <li>unnecessary downstream calls</li>
          <li>blocking I/O</li>
          <li>overly expensive validation</li>
          <li>logic executed too early in the request lifecycle</li>
        </ul>

        <p>
          None of these require traffic spikes to cause pain.
          They are baked into every request.
        </p>

        <h2>The practical workflow</h2>
        <p>
          This is where the test becomes useful, not theoretical.
        </p>

        <ol>
          <li>Import a cURL</li>
          <li>Send a request</li>
          <li>Verify the response</li>
          <li>Adjust field mappings if needed</li>
          <li>Run tests</li>
        </ol>

        <p>
          After a few minutes, you don’t just get:
        </p>

        <ul>
          <li>data-driven test results</li>
          <li>security checks</li>
          <li>error handling validation</li>
        </ul>

        <p>
          You also get performance insights —
          based on real request behavior,
          not synthetic benchmarks.
        </p>

        <h2>When the test fails</h2>
        <p>
          If the median response time exceeds the threshold,
          the test is marked as failed.
        </p>

        <p>
          Not as a warning.
          Not as “interesting to monitor”.
          As a clear signal.
        </p>

        <p>
          And this is the best part:
          you don’t need to explain it.
        </p>

        <p>
          Next to the failed test,
          Rentgen provides a <strong>Copy Bug Report</strong> action.
        </p>

        <p>
          One click copies a clean, professional bug report
          describing:
        </p>

        <ul>
          <li>what was tested</li>
          <li>what failed</li>
          <li>the measured response times</li>
          <li>why this is a problem</li>
        </ul>

        <p>
          Paste it into Jira, Trello, Slack —
          whatever your team uses.
        </p>

        <p>
          No screenshots.
          No explanations.
          No performance lectures.
        </p>

        <h2>Why this check exists in Rentgen</h2>
        <p>
          Because performance problems don’t start with load.
        </p>

        <p>
          They start with slow, inefficient request handling
          that nobody notices
          because “functionally, it works”.
        </p>

        <p>
          Rentgen makes that visible early —
          without requiring a separate tool,
          a separate test phase,
          or a separate discussion.
        </p>

        <h2>Final thoughts</h2>
        <p>
          You don’t need a full load test
          to know when something is wrong.
        </p>

        <p>
          If your API is slow when nobody is using it,
          it won’t magically improve under traffic.
        </p>

        <p>
          Median response time doesn’t lie.
          It just tells you something
          you might not want to hear yet.
        </p>
      </div>
    </article>

  </main>

  <footer class="site-footer">
    <div class="container footer-inner">
      <span>© <span id="year"></span> Rentgen</span>
      <span class="footer-note">Built for testers, by a tester.</span>
    </div>
  </footer>

  <script src="../script.js"></script>
</body>
</html>
