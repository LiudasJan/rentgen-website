<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>API Story: Cache-Control for Private API — preventing “ghost data” in caches</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description"
    content="Rentgen is a secure, local-only API testing tool. No accounts, no tracking, no logging – just deep backend tests that stay on your machine." />
  <link rel="canonical" href="https://rentgen.io/api-stories/uppercase-path-handling.html" />

  <!-- Favicon -->
  <link rel="icon" type="image/x-icon" href="../assets/favicon.ico" />
  <link rel="icon" type="image/png" href="../assets/rentgen-logo.png" />
  <link rel="apple-touch-icon" href="../assets/rentgen-logo.png" />

  <!-- Open Graph / Social -->
  <meta property="og:title" content="Rentgen – Secure Local API Testing Tool" />
  <meta property="og:description" content="No cloud. No tracking. No logs. Just brutal API testing on your machine." />
  <meta property="og:image" content="https://rentgen.io/assets/og-image.png" />
  <meta property="og:url" content="https://rentgen.io/" />
  <meta property="og:type" content="website" />

  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="Rentgen – Secure Local API Testing Tool" />
  <meta name="twitter:description" content="No cloud. No tracking. No logs. Just brutal API testing on your machine." />
  <meta name="twitter:image" content="https://rentgen.io/assets/og-image.png" />

  <link rel="stylesheet" href="../styles.css" />
</head>

<body>
  <header class="site-header">
    <div class="container header-inner">
      <a href="https://rentgen.io/#top" class="brand">
        <img src="../assets/rentgen-logo.png" class="brand-logo" />
        <span class="brand-name">Rentgen</span>
      </a>
      <button class="nav-toggle" aria-label="Toggle navigation">
        <span></span><span></span>
      </button>
      <nav class="site-nav">
        <a href="https://rentgen.io/#features">Features</a>
        <a href="https://rentgen.io/#security">Security</a>
        <a href="https://rentgen.io/#downloads">Downloads</a>
        <a href="https://rentgen.io/#cases">Case studies</a>
        <a href="https://rentgen.io/#github">GitHub</a>
        <a href="https://rentgen.io/api-stories/">API Stories</a>
      </nav>
    </div>
  </header>

  <main class="section">

    <article class="container article">
  <header class="article-header">
    <h1>Uppercase Path Handling — when <code>/V1</code> quietly ruins your entire day</h1>
    <p class="article-meta">
      Rentgen API Stories · January 2026
    </p>
  </header>

  <div class="article-content">
    <p>
      This is one of those bugs that feels embarrassing to admit —
      not because it’s rare, but because everyone has seen it,
      and almost nobody tests for it.
    </p>

    <p>
      Someone writes <code>/V1/users</code> instead of <code>/v1/users</code>.
      The API responds with <code>400 Bad Request</code>, <code>404</code>,
      or something equally unhelpful.
      And suddenly, half a day disappears into debugging.
    </p>

    <h2>What was tested</h2>
    <p>
      Rentgen takes a known, valid API request and mutates only the path —
      everything after the domain is converted to uppercase.
    </p>

    <ul>
      <li><strong>TEST:</strong> Uppercase Path Test</li>
      <li><strong>Mutation:</strong> URL path converted to uppercase</li>
      <li><strong>Expected:</strong>
        <ul>
          <li><code>404 Not Found</code> — resource does not exist</li>
          <li>or <code>2xx</code> — API explicitly treats paths as case-insensitive</li>
        </ul>
      </li>
      <li><strong>Anything else:</strong> misleading behavior</li>
    </ul>

    <h2>Why this matters</h2>
    <p>
      Unlike domain names, URL paths are usually treated as case-sensitive.
      That means <code>/v1</code> and <code>/V1</code> are different resources.
      And that’s fine — as long as the API communicates that clearly.
    </p>

    <p>
      The problem starts when the API responds with something vague or misleading.
      A <code>400 Bad Request</code> suggests the payload is wrong.
      A <code>403 Forbidden</code> suggests permissions.
      A <code>500</code> suggests the server broke.
    </p>

    <p>
      None of those point to the real issue:
      <em>the resource simply does not exist</em>.
    </p>

    <h2>The debugging trap</h2>
    <p>
      This is how it usually plays out:
    </p>

    <ul>
      <li>One developer types <code>/V1</code> instead of <code>/v1</code></li>
      <li>The API returns <code>400</code></li>
      <li>They inspect the payload</li>
      <li>They compare headers</li>
      <li>They re-run the request multiple times</li>
      <li>They compare it with a colleague’s request that “works”</li>
    </ul>

    <p>
      Everything looks identical.
      Same endpoint. Same body. Same auth.
    </p>

    <p>
      The difference hides in plain sight:
      one character.
      One uppercase letter.
    </p>

    <p>
      When it’s finally spotted, the reaction is always the same:
      <em>“Wait… seriously?”</em>
    </p>

    <h2>What Rentgen found</h2>
    <p>
      In a correct implementation, one of two behaviors is acceptable:
    </p>

    <ul>
      <li>
        <strong>Strict routing:</strong>
        return <code>404 Not Found</code> because <code>/V1</code> is not a valid resource
      </li>
      <li>
        <strong>Normalized routing:</strong>
        treat <code>/v1</code> and <code>/V1</code> as equivalent and return <code>2xx</code>
      </li>
    </ul>

    <p>
      Both are defensible.
      What’s not defensible is returning something that sends developers
      looking in the wrong direction.
    </p>

    <h2>Why this bug survives</h2>
    <p>
      Because it sits in an awkward gap:
    </p>
    <ul>
      <li>too small to be a feature bug</li>
      <li>too inconsistent to reproduce easily</li>
      <li>too embarrassing to write a test for manually</li>
    </ul>

    <p>
      Testers rarely try random casing in paths.
      Developers assume URLs are copied, not typed.
      And tooling often hides the actual string being sent.
    </p>

    <h2>Real-world impact</h2>
    <p>
      This issue doesn’t bring systems down.
      It does something worse:
      it quietly burns time.
    </p>

    <ul>
      <li>hours lost debugging payloads</li>
      <li>support tickets that can’t be reproduced</li>
      <li>“works on my machine” arguments</li>
      <li>unnecessary blame on auth, data, or infrastructure</li>
    </ul>

    <p>
      All because the API didn’t clearly say:
      “this resource does not exist”.
    </p>

    <h2>How to fix it</h2>
    <p>
      Pick a behavior and make it explicit:
    </p>
    <ul>
      <li>If paths are case-sensitive, return a clean <code>404</code></li>
      <li>If you normalize paths, do it consistently and document it</li>
      <li>Never turn path casing into a <code>400</code> or <code>500</code></li>
    </ul>

    <p>
      The goal is not flexibility.
      The goal is predictability.
    </p>

    <h2>Why this check exists in Rentgen</h2>
    <p>
      Because this bug is too small for people to think about —
      and too expensive to ignore when it hits.
    </p>

    <p>
      Rentgen checks it automatically so you don’t have to discover it
      during a debugging session that ends with:
      <em>“Oh… you used a capital letter.”</em>
    </p>

    <h2>Final thoughts</h2>
    <p>
      APIs don’t fail only on complex edge cases.
      Sometimes they fail on typography.
    </p>

    <p>
      If your API handles uppercase paths predictably,
      you remove an entire class of pointless debugging.
      And that’s a bigger win than it sounds.
    </p>
  </div>
</article>


  </main>

  <footer class="site-footer">
    <div class="container footer-inner">
      <span>© <span id="year"></span> Rentgen</span>
      <span class="footer-note">Built for testers, by a tester.</span>
    </div>
  </footer>

  <script src="../script.js"></script>
</body>
</html>
