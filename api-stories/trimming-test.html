<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Trimming Test — when one invisible space creates two “unique” records</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="Why trimming string input in APIs matters. A real-world example showing how leading or trailing whitespace breaks uniqueness, integrations, and client assumptions — and how Rentgen detects it early." />
  <meta name="keywords" content="API trimming, input normalization, whitespace bug, API validation, string canonicalization, API hygiene, backend validation, integration bugs, Rentgen API Stories" />
  <link rel="canonical" href="https://rentgen.io/api-stories/trimming-test.html" />

  <!-- Favicon -->
  <link rel="icon" type="image/x-icon" href="../assets/favicon.ico" />
  <link rel="icon" type="image/png" href="../assets/rentgen-logo.png" />
  <link rel="apple-touch-icon" href="../assets/rentgen-logo.png" />

  <!-- Open Graph / Social -->
  <meta property="og:title" content="Rentgen – Secure Local API Testing Tool" />
  <meta property="og:description" content="No cloud. No tracking. No logs. Just brutal API testing on your machine." />
  <meta property="og:image" content="https://rentgen.io/assets/og-image.png" />
  <meta property="og:url" content="https://rentgen.io/" />
  <meta property="og:type" content="website" />

  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="Rentgen – Secure Local API Testing Tool" />
  <meta name="twitter:description" content="No cloud. No tracking. No logs. Just brutal API testing on your machine." />
  <meta name="twitter:image" content="https://rentgen.io/assets/og-image.png" />

  <link rel="stylesheet" href="../styles.css" />
</head>

<body>
  <header class="site-header">
    <div class="container header-inner">
      <a href="https://rentgen.io/#top" class="brand">
        <img src="../assets/rentgen-logo.png" class="brand-logo" />
        <span class="brand-name">Rentgen</span>
      </a>
      <button class="nav-toggle" aria-label="Toggle navigation">
        <span></span><span></span>
      </button>
      <nav class="site-nav">
        <a href="https://rentgen.io/#features">Features</a>
        <a href="https://rentgen.io/#security">Security</a>
        <a href="https://rentgen.io/#downloads">Downloads</a>
        <a href="https://rentgen.io/#cases">Case studies</a>
        <a href="https://rentgen.io/#github">GitHub</a>
        <a href="https://rentgen.io/api-stories/">API Stories</a>
      </nav>
    </div>
  </header>

    <main class="section">
      <article class="container article">
        <header class="article-header">
          <h1>Trimming Test — when one invisible space creates two “unique” records</h1>
          <p class="article-meta">
            Rentgen API Stories · January 2026
          </p>
        </header>

        <div class="article-content">
          <p>
            Trimming is one of those checks that looks too small to matter.
            Until you ship an integration that assumes data is clean — and it isn’t.
          </p>

          <p>
            This is not a “nice to have” style preference.
            It is input canonicalization. It affects uniqueness, idempotency, caching keys, searches, and downstream clients
            that make perfectly reasonable assumptions.
          </p>

          <h2>What this test is — and what it is not</h2>

          <p>
            This is not about formatting the user’s input to be polite.
            It is about preventing logically identical values from becoming different values in storage and integrations.
          </p>

          <p>
            Rentgen’s trimming test asks a simple question:
            when a string contains leading or trailing whitespace, does the API normalize it or reject it explicitly?
          </p>

          <h2>What was tested</h2>

          <figure>
            <img width="100%" src="../assets/api-stories/trimming-test.png" alt="Trimming test in Rentgen" />
            <figcaption>Trimming test in Rentgen</figcaption>
          </figure>

          <p>
            Rentgen sent a request where <code>body.operation</code> contained extra whitespace:
            the value was valid after trimming, but invalid as-is.
          </p>

          <ul>
            <li><strong>Field:</strong> <code>body.operation</code></li>
            <li><strong>Injected value:</strong> <code>"&nbsp;&nbsp;divide&nbsp;&nbsp;"</code></li>
            <li><strong>Expected behavior:</strong> reject as invalid <em>or</em> normalize before validation</li>
          </ul>

          <p>
            The key here is not the calculator example itself.
            The same pattern applies to any API that accepts user-provided strings:
            usernames, external IDs, tags, product codes, email-like identifiers, slugs, names, “unique” keys.
          </p>

          <h2>What Rentgen found</h2>

          <p>
            The API returned an error for the whitespace-padded value, effectively treating it as a different operation.
            That is a valid choice <em>only</em> if the API contract explicitly defines whitespace as meaningful.
          </p>

          <p>
            In most real systems, whitespace is not meaningful — it is accidental.
            The problem starts when the backend accepts accidental whitespace in some endpoints, but not in others.
          </p>

          <h2>Why this matters</h2>

          <p>
            Here is the classic integration failure:
            your API accepts a string field that must be unique.
            Backend validation exists. A database unique index exists. Everything looks correct.
            Then a user makes a tiny mistake and sends the same value with an extra space.
          </p>

          <p>
            If the API stores the value as-is, you can end up with two records that are logically identical to the client
            but different to the database. When you later return the dataset, the client sees duplicates and breaks
            (or worse — merges incorrectly).
          </p>

          <p>
            This is how you get production bugs that are extremely hard to reproduce:
            all data “looks” correct to humans, but the system treats it as different because of invisible characters.
          </p>

          <h2>Why most teams miss this</h2>

          <p>
            Because manual testing is clean by default.
            Testers and developers type values carefully. They copy-paste correct examples. They do not intentionally add
            whitespace to a value they already know is valid.
          </p>

          <p>
            And when issues do appear, they are usually blamed on “client-side mistakes” instead of being treated as a
            backend contract and canonicalization problem.
          </p>

          <h2>Two correct outcomes</h2>

          <p>
            For trimming tests, there are only two outcomes that scale:
          </p>

          <ul>
            <li>
              <strong>Reject as invalid (400 / 422)</strong> — if whitespace is forbidden and must be explicit in the contract.
            </li>
            <li>
              <strong>Normalize (trim) before validation and storage</strong> — if whitespace is accidental and should not create new values.
            </li>
          </ul>

          <p>
            The dangerous outcome is the third one:
            accepting untrimmed values in some places and trimming them in others.
            That creates inconsistencies between create/update/search/list endpoints.
          </p>

          <h2>What else matters besides a simple space</h2>

          <p>
            Trimming is not just about the obvious <code>" "</code>.
            Real systems break on whitespace variants that humans do not notice:
          </p>

          <ul>
            <li><strong>Tabs and newlines</strong> (<code>\t</code>, <code>\n</code>, <code>\r</code>)</li>
            <li><strong>Non-breaking space</strong> (NBSP, <code>U+00A0</code>)</li>
            <li><strong>Unicode whitespace</strong> (thin spaces, zero-width characters, copy-paste artifacts)</li>
            <li><strong>Double spaces inside values</strong> (normalization rules must be consistent if you choose to compress whitespace)</li>
          </ul>

          <p>
            If you normalize, you must normalize consistently — across create, update, search, and comparisons.
            If you reject, you must reject consistently — and return a clear error that helps clients fix input.
          </p>

          <h2>Why this check exists in Rentgen</h2>

          <p>
            Because trimming bugs are not “edge cases”.
            They are common, human, and inevitable — and they quietly create data integrity problems that surface later,
            when multiple systems depend on the same identifiers.
          </p>

          <p>
            Rentgen runs this test because it is easy to forget, easy to dismiss, and expensive to debug after the fact.
          </p>

          <h2>Final thoughts</h2>

          <p>
            Invisible characters create visible failures.
            If your API treats accidental whitespace as a new value, you will eventually store duplicates,
            break uniqueness assumptions, and ship integration bugs that feel “random”.
          </p>

          <p>
            Reject it or normalize it.
            But never leave it undefined.
          </p>
        </div>
      </article>
    </main>

  <footer class="site-footer">
    <div class="container footer-inner">
      <span>© <span id="year"></span> Rentgen</span>
      <span class="footer-note">Built for testers, by a tester.</span>
    </div>
  </footer>

  <script src="../script.js"></script>
</body>
</html>
